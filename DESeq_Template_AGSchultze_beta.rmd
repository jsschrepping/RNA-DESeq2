---
title: "DESeq2 RNA-seq Analysis Template"
author: "Stefanie Herresthal, Nico Reusch, Jonas Schulte-Schrepping"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document: 
    toc: true
    toc_float: true
---

# 1. R requirements

## Install and load packages

First, we install all necessary CRAN and Bioconductor packages and load them into the R session.

### Install CRAN
```{r}
# CRAN packages
list.of.packages <- c("tidyr",
                      "ggplot2",
                      "ggrepel",
                      "gplots",
                      "ggbeeswarm",
                      "hexbin",
                      "reshape2",
                      "factoextra",
                      "Hmisc",
                      "VennDiagram",
                      "openxlsx")

new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]

if(length(new.packages)>0) install.packages(new.packages)
```

### Install BioConductor

```{r}
# BioconductoR packages
list.of.bioc.packages<- c("rhdf5",
                          "clusterProfiler",
                          "DOSE",
                          "GSEABase",
                          "RColorBrewer",
                          "ComplexHeatmap",
                          "tximport",
                          "DESeq2",
                          "vsn",
                          "pheatmap",
                          "genefilter",
                          "biomaRt",
                          "limma",
                          "sva",
                          "IHW",
                          "org.Mm.eg.db",
                          "org.Hs.eg.db")

new.packages.bioc <- list.of.bioc.packages[!(list.of.bioc.packages %in% installed.packages()[,"Package"])]
 
if(length(new.packages.bioc)>0)if (!requireNamespace("BiocManager")) install.packages("BiocManager")
BiocManager::install(new.packages.bioc, update = FALSE)
```

### Load Packages

```{r load packages, results='hide',message=FALSE,warning=FALSE}
lapply(c(list.of.packages,list.of.bioc.packages), require, character.only = TRUE)
```

## Custom functions

We define functions used for analysis and visualization of our data. Most of our plots are based on ggplot2, so you can add different themes our change scales, etc. 
Example:
DEcompare$KEGGplot+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

### Heatmap colors
```{r}
scaleColors <- function(data = input_scale, # data to use
                        maxvalue = NULL # value at which the color is fully red / blue
                        ){
  if(is.null(maxvalue)){
    maxvalue <- floor(min(abs(min(data)), max(data)))
  }
  if(max(data) > abs(min(data))){
    if(ceiling(max(data)) == maxvalue){
      myBreaks <- c(floor(-max(data)), seq(-maxvalue+0.2, maxvalue-0.2, 0.2),  ceiling(max(data)))
    } else{
      myBreaks <- c(floor(-max(data)), seq(-maxvalue, maxvalue, 0.2),  ceiling(max(data)))
    }
    paletteLength <- length(myBreaks)
    myColor <- colorRampPalette(c("blue", "white", "red"))(paletteLength)
  } else {
    if(-floor(min(data)) == maxvalue){
      myBreaks <- c(floor(min(data)), seq(-maxvalue+0.2, maxvalue-0.2, 0.2),  ceiling(min(data)))
    } else{
      myBreaks <- c(floor(min(data)), seq(-maxvalue, maxvalue, 0.2),  ceiling(abs(min(data))))
    }
    paletteLength <- length(myBreaks)
    myColor <- colorRampPalette(c("blue", "white", "red"))(paletteLength)
  }
 return(list(breaks = myBreaks, color = myColor))
}
```

### BoxPlot of highest expressed genes
```{r}
highestGenes <- function(numGenes=10){
  tmp <- norm_anno[,colnames(norm_anno) %in% sample_table$ID]
  tmp <- tmp[order(rowMeans(tmp), decreasing = T),]
  tmp <- tmp[1:numGenes,]
  tmp <- melt(t(tmp))
  colnames(tmp)<- c("sample","gene","value")
  
  idx <- match(tmp$gene,norm_anno$GENEID)
  tmp$symbol <- as.factor(norm_anno$SYMBOL[idx])
  tmp$symbol <- factor(tmp$symbol, levels = rev(unique(tmp$symbol)))
  
  ggplot(tmp, aes(x = tmp$symbol, y = value)) +
      geom_boxplot()+
      xlab("Gene")+
      ylab("Normalized Expression")+
      ggtitle(paste("Expression of", numGenes, "highest expressed genes")) + 
      theme_bw() +
      coord_flip() +
      theme(axis.text.x = element_text(size=8, angle = 90, hjust = 1),
            plot.title = element_text(size = 8, face = "bold"))
}
```

### Heatmap
```{r}
plotHeatmap <- function(input=norm_anno,
                        geneset,
                    title="",
                    keyType = "Ensembl",
                    show_rownames = FALSE,
                    cluster_cols = FALSE,
                    font.size=7,
                    max.value=2){
  if(geneset[1] =="all"){
    input <- input
  }else{
    if(keyType == "Ensembl"){
      input <- input[input$GENEID %in% geneset,]
    } else if(keyType == "Symbol"){
      input <- input[input$SYMBOL %in% geneset,]
    } else{
      print("Wrong keyType. Choose Ensembl or Symbol!")
    }
  }
  rownames(input) <- paste(input$GENEID, ":", input$SYMBOL, sep="")
  input <- input[,colnames(input) %in% sample_table$ID]
  input_scale <- t(scale(t(input)))
  input_scale <- input_scale[,order(sample_table[[plot_order]], decreasing = FALSE)]

  pheatmap(input_scale,
         main=title,
         show_rownames=show_rownames,
         show_colnames=TRUE,
         cluster_cols = cluster_cols, 
         fontsize = font.size,
         annotation_col = plot_annotation,
         annotation_colors = ann_colors,
         breaks = scaleColors(data = input_scale, maxvalue = max.value)[["breaks"]], 
         color = scaleColors(data = input_scale, maxvalue = max.value)[["color"]])
}
```

### Heatmap of genes of specified gene sets
```{r}
plotGeneSetHeatmap <- function(input=norm_anno,
                               cat,
                               term,
                               organism,
                               show_rownames =TRUE, 
                               cluster_cols = FALSE,
                               font.size= 7,
                               max.value=2){
  if(organism == "mouse"){
    GO <- GO_mm
    KEGG <- KEGG_mm
  } else if(organism == "human"){
    GO <- GO_hs
    KEGG <- KEGG_hs
  } else (stop("Wrong organism specified!"))
  
  xterm <- paste("^", term, "$", sep="")
  if(cat=="GO"){
    genes <- unique(GO[grep(xterm,GO$TERM),"SYMBOL"])
  }
  if(cat=="KEGG"){
    genes <- unique(KEGG[grep(xterm,KEGG$PATHWAY),"SYMBOL"])
  }
  if(cat=="Hallmark"){
    genes <- unique(hallmark_genes[grep(xterm,hallmark_genes$ont),"gene"])
  }
  if(cat=="cannonicalPathways"){
    genes <- unique(cannonicalPathway_genes[grep(xterm,cannonicalPathway_genes$ont),"gene"])
  }
  if(cat=="ImmunoSignatures"){
    genes <- unique(immuno_genes[grep(xterm,immuno_genes$ont),"gene"])
  }
  if(cat=="Motifs"){
    genes <- unique(motifs[grep(xterm,motifs$ont),"gene"])
  }
  if(organism == "mouse" & 
     cat == "Hallmark"|
     cat == "cannonicalPathways"| 
     cat =="ImmunoSignatures"|
     cat == "Motifs"){
    genes <- getLDS(attributes = c("entrezgene"), 
                    filters = "entrezgene", 
                    values = genes, 
                    mart = useMart("ensembl", dataset = "hsapiens_gene_ensembl"), 
                    attributesL = c("mgi_symbol"), 
                    martL = useMart("ensembl", dataset = "mmusculus_gene_ensembl"), 
                    uniqueRows=T)[,2]
  }
  
  plotHeatmap(input=input,geneset = genes,
              keyType = "Symbol",
              title = paste("Heatmap of present genes annotated to: ",term, sep=""),
              show_rownames = show_rownames,
              cluster_cols = cluster_cols,
              font.size=font.size,
              max.value=max.value)
}
```

### PCA function
```{r}
plotPCA <- function(pca_input = dds_vst,
                     ntop=500, 
                     xPC=1, 
                     yPC=2,
                     color,
                     anno_colour,
                     shape="NULL",
                     point_size=3,
                     title="PCA", 
                    label = NULL, 
                    label_subset = NULL){
  
  if(!is.data.frame(pca_input)){
  vst_matrix <-as.matrix(assay(pca_input))
  }else{
   vst_matrix <- pca_input
  }
  
  if(ntop=="all"){
    pca <- prcomp(t(vst_matrix)) 
  }else{
    # select the ntop genes by variance
    select <- order(rowVars(vst_matrix), decreasing=TRUE)[c(1:ntop)]
    pca <- prcomp(t(vst_matrix[select,]))
  }
  
  #calculate explained variance per PC
  explVar <- pca$sdev^2/sum(pca$sdev^2)
  # transform variance to percent
  percentVar <- round(100 * explVar[c(xPC,yPC)], digits=1)

  # Define data for plotting  
  pcaData <- data.frame(xPC=pca$x[,xPC], 
                        yPC=pca$x[,yPC], 
                        color = sample_table[[color]],
                        name= as.character(sample_table$ID),
                        stringsAsFactors = F)
  
  #plot PCA
  if(is.factor(pcaData$color) || is.character(pcaData$color)|| is.integer(pcaData$color)){
    if(shape == "NULL"){
        pca_plot <- ggplot(pcaData, aes(x = xPC, y = yPC, colour=color)) +
                          geom_point(size =point_size)
      }else{
        pcaData$shape = sample_table[[shape]]
        pca_plot <- ggplot(pcaData, aes(x = xPC, y = yPC, colour=color, shape=shape)) +
                          geom_point(size =point_size) +
                          scale_shape_discrete(name=shape)
      }
    
    if(anno_colour[1] == "NULL"){
        pca_plot <- pca_plot + scale_color_discrete(name=color)
    }else{
        pca_plot <- pca_plot + scale_color_manual(values=anno_colour, name=color)
    }
    
  }else if(is.numeric(pcaData$color)){
      if(shape == "NULL"){
        pca_plot <- ggplot(pcaData, aes(x = xPC, y = yPC, colour=color)) +
          geom_point(size =point_size) +
          scale_color_gradientn(colours = bluered(100),name=color)
      }else{
        pcaData$shape = sample_table[[shape]]
        pca_plot <- ggplot(pcaData, aes(x = xPC, y = yPC, colour=color, shape=shape)) +
          geom_point(size =point_size) +
          scale_color_gradientn(colours = bluered(100),name=color)+
          scale_shape_discrete(name=shape)
      }
  }

# adds a label to the plot. To label only specific points, put them in the arument label_subset
  if (!is.null(label) == TRUE){
    pcaData$label <- sample_table[[label]]
    if(!is.null(label_subset) == TRUE){
    pcaData_labeled <- pcaData[pcaData$label %in% label_subset,]
    } else {
      pcaData_labeled <- pcaData
    }
      pca_plot <- pca_plot + 
      geom_text_repel(data = pcaData_labeled, aes(label = label), nudge_x = 2, nudge_y = 2, colour = "black") 
  }
  
    pca_plot <- pca_plot+
    xlab(paste0("PC ",xPC, ": ", percentVar[1], "% variance")) +
    ylab(paste0("PC ",yPC,": ", percentVar[2], "% variance")) +
    coord_fixed()+
    theme_classic()+        
    theme(aspect.ratio = 1)+
    ggtitle(title)
  
  pca_plot
}
```

### Heatmaps of PC loadings
```{r}
plotLoadings <- function(PC, 
                         ntop,
                         font.size=7,
                         cluster_cols=TRUE){
  if(ntop=="all"){
    pca <- prcomp(t(assay(dds_vst))) 
  }else{
    select <- order(rowVars(assay(dds_vst)), decreasing=TRUE)[c(1:ntop)]
    pca <- prcomp(t(assay(dds_vst)[select,]))
  }

  Loadings <- pca$rotation[,PC]
  Loadings <- Loadings[order(Loadings, decreasing = T)]
  Loadings <- names(Loadings[c(1:20,(length(Loadings)-19):length(Loadings))])
  
  heatmap <- norm_anno[norm_anno$GENEID %in% Loadings,]
  rownames(heatmap) <- paste(heatmap$GENEID,": ",heatmap$SYMBOL,sep="")  
  heatmap <- heatmap[,colnames(heatmap) %in% sample_table$ID]
  heatmap_scale <- as.matrix(t(scale(t(heatmap))))
  heatmap_scale <- heatmap_scale[,order(sample_table[[plot_order]], decreasing = FALSE)]
  
  # Heatmap
  pheatmap(heatmap_scale,
           main=paste("Hierarchical Clustering of top20 ",PC, " loadings in both directions",sep=""),
           show_rownames=TRUE,
           show_colnames = TRUE,
           annotation_col = plot_annotation,
           annotation_colors = ann_colors,
           breaks = scaleColors(heatmap_scale, 2)[["breaks"]], 
           color = scaleColors(heatmap_scale, 2)[["color"]],
           cluster_cols = cluster_cols,
           fontsize=font.size)
}
```

### MultiPlot
```{r}
multiplot<-function(plots=plots,
                    cols=1){

  layout <- matrix(seq(1, cols * length(plots)/cols),
                     ncol = cols, 
                     nrow = length(plots)/cols)

  
  if (length(plots)==1) {
    print(plots[[1]])
  }else{
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    for (i in 1:length(plots)){
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
```

### Boxplot of normalized or batch-corrected counts for a single gene
```{r}
plotSingleGene <-function(data=norm_anno, 
                            symbol, 
                            condition="Genotype_Age", 
                            anno_colour=col_genotype_age,
                            shape = NULL) {
  
  input<-as.data.frame(data)
  rownames(input)<- input$GENEID

  if(sum(input$SYMBOL == symbol) == 0){
    stop("Gene not present")
  }else{
    plots<-list()
    for (i in 1:sum(input$SYMBOL == symbol)) {
      geneCounts <- as.data.frame(t(input[input$SYMBOL == symbol, colnames(input) %in% sample_table$ID]))
      geneCounts$condition <- sample_table[[condition]]
      GENEID<-colnames(geneCounts)[i]
      colnames(geneCounts)[i]<-"y"
      
      if(!is.null(anno_colour)){
        if (is.null(shape)){
          plot<-ggplot(geneCounts, aes(x = condition, y = y, colour=condition)) +
            scale_color_manual(values=anno_colour)+
            geom_beeswarm(cex = 3, na.rm=T) 
        }else{
          geneCounts$shape <- sample_table[[shape]]
          legend_shape<-paste0(shape)
          plot<-ggplot(geneCounts, aes(x = condition, y = y, colour=condition)) +
            scale_color_manual(values=anno_colour)+
            geom_beeswarm(cex = 3, na.rm=T, aes(shape=shape)) +
            scale_shape(name=legend_shape)
        }
      }else{
        if (is.null(shape_opt)){
          plot<-ggplot(geneCounts, aes(x = condition, y = y, colour=condition)) +
            scale_color_brewer(palette = "Spectral")+
            geom_beeswarm(cex = 3, na.rm=T, aes(size=3))
        }else{
          geneCounts$shape <- sample_table[[shape]]
          legend_shape<-paste0(shape)
          plot<-ggplot(geneCounts, aes(x = condition, y = y, colour=condition)) +
            scale_color_brewer(palette = "Spectral")+
            geom_beeswarm(cex = 3, na.rm=T, aes(shape=shape)) +
            scale_shape(name=legend_shape)
        }
      }
      plots[[i]]<-plot+
              geom_boxplot(width=.5,alpha=0) + 
              stat_boxplot(geom ='errorbar',width=.25) +
              ylab("Normalized counts") +
              scale_y_continuous(expand=c(0.05,0.25)) +
              expand_limits(y=0) +
              labs(title=paste(symbol, GENEID, sep=": "),colour=condition)+
              theme_classic()+
              theme(plot.title = element_text(hjust=0.5))
    }
    if(sum(input$SYMBOL== symbol)>1){
      print("Selected gene symbol assigned to more than one gene (Ensembl ID)")
      multiplot(plots)
    }else{
      print("Selected gene symbol assigned to one gene (Ensembl ID)")
      multiplot(plots)
    }
  }
}
```


### Remove potential batch effects using the removeBatchEffect function from limma
```{r}
limmaBatchEffectRemoval <- function(input=dds_vst,
                                       batchfactor, # name of batch effect column in sample_table
                                       batchfactor_2=NULL,
                                       modelfactor){ # name of model effect column in sample_table
  
  # rlog-transformed input
  x <- as.matrix(assay(input)) 
  
  # design matrix
  model <- model.matrix(~sample_table[,c(modelfactor)])
  
  # run batch remocal function
  if(is.numeric(sample_table[,colnames(sample_table) == batchfactor[1]])==T){
    as.data.frame(removeBatchEffect(x,
                                    covariates = sample_table[,colnames(sample_table) %in% batchfactor],
                                    design = model))
    }else{
      if(is.null(batchfactor_2)){
        as.data.frame(removeBatchEffect(x=x,
                                        batch = sample_table[,colnames(sample_table) == batchfactor],
                                        design = model))
      }else{
        as.data.frame(removeBatchEffect(x=x,
                                        batch = sample_table[,colnames(sample_table) == batchfactor],
                                        batch2 = sample_table[,colnames(sample_table) == batchfactor_2],
                                        design = model))
      }
    }
}
```

### DESeq2 output
```{r}
# Specify structure of DESeq2_analysis_object
setClass(Class = "DESeq2_analysis_object",
         slots = c(results="data.frame", DE_genes="list", Number_DE_genes="list"))


# Wrapper Function to perform DESeq2 differential testing
DEAnalysis <- function(condition,
                       alpha = 0.05, 
                       lfcThreshold = 0,
                       sigFC = 2, 
                       multiple_testing = "IHW",
                       independentFiltering="TRUE",
                       shrinkage = TRUE,
                       shrinkType = "normal"){
  # create results_list  
  results_list <- list()
  # print parameters
  results_list$parameters <-list(multiple_testing = multiple_testing,
                                 p_value_threshold = alpha,
                                 log2_FC_threshold = lfcThreshold,
                                 shrinkage = shrinkage,
                                 shrinkage_type = shrinkType)
  # Run results() function on comparisons defined in comparison table
  for (i in 1:nrow(comparison_table)){
    # create DE_object
    DE_object <- new(Class = "DESeq2_analysis_object")
    # IHW
    if (multiple_testing=="IHW") {
      res_deseq_lfc <- results(dds,
                               contrast = c(condition,
                                            paste(comparison_table$comparison[i]),
                                            paste(comparison_table$control[i])),
                               lfcThreshold = lfcThreshold,
                               alpha = alpha,
                               filterFun = ihw,
                               altHypothesis = "greaterAbs")
      # Independent Filtering
    }else {
      res_deseq_lfc <- results(dds,
                               contrast = c(condition,
                                            paste(comparison_table$comparison[i]),
                                            paste(comparison_table$control[i])),
                               lfcThreshold = lfcThreshold,
                               alpha = alpha,
                               independentFiltering = independentFiltering,
                               altHypothesis = "greaterAbs",
                               pAdjustMethod= multiple_testing)
    }
    if(shrinkage == TRUE){
      res_deseq_lfc <- lfcShrink(dds, 
                                 contrast = c(condition,
                                              paste(comparison_table$comparison[i]),
                                              paste(comparison_table$control[i])),
                                 res=res_deseq_lfc,
                                 type = shrinkType)
    }
    res_deseq_lfc <- as.data.frame(res_deseq_lfc)
    # indicate significant DE genes  
    res_deseq_lfc$regulation <- ifelse(!is.na(res_deseq_lfc$padj)&
                                         res_deseq_lfc$padj <= alpha&
                                         res_deseq_lfc$log2FoldChange > log(sigFC,2),
                                       "up",
                                       ifelse(!is.na(res_deseq_lfc$padj)&
                                                res_deseq_lfc$padj <= alpha&
                                                res_deseq_lfc$log2FoldChange < -log(sigFC,2),
                                              "down",
                                              "n.s."))
    # add gene annotation to results table
    res_deseq_lfc$GENEID <- row.names(res_deseq_lfc) # ensembl-IDs as row names
    res_deseq_lfc <- merge(res_deseq_lfc, 
                           norm_anno[,c("GENEID", 
                                        "SYMBOL", 
                                        "GENETYPE",
                                        "DESCRIPTION",
                                        "CHR")], 
                           by = "GENEID") 
    row.names(res_deseq_lfc) <- res_deseq_lfc$GENEID
    res_deseq_lfc$comparison<-paste(comparison_table$comparison[i]," vs ",comparison_table$control[i],
                                    sep="")
    # re-order results table
    if (multiple_testing=="IHW") {
      res_deseq_lfc<-res_deseq_lfc[,c("GENEID",
                                     "SYMBOL",
                                     "GENETYPE",
                                     "DESCRIPTION",
                                     "CHR",
                                     "comparison",
                                     "regulation",
                                     "baseMean",
                                     "log2FoldChange",
                                     "lfcSE",
                                     "stat",
                                     "pvalue",
                                     "padj",
                                     "weight")]
    }else{
      res_deseq_lfc<-res_deseq_lfc[,c("GENEID",
                                      "SYMBOL",
                                      "GENETYPE",
                                      "DESCRIPTION",
                                      "CHR",
                                      "comparison",
                                      "regulation",
                                      "baseMean",
                                      "log2FoldChange",
                                      "lfcSE",
                                      "stat",
                                      "pvalue",
                                      "padj")]
    }
    # print result table
    DE_object@results <- res_deseq_lfc
    # print DE genes in seperate tables
    DE_object@DE_genes <- list(up_regulated_Genes = res_deseq_lfc[res_deseq_lfc$regulation =="up",],
                               down_regulated_Genes= res_deseq_lfc[res_deseq_lfc$regulation =="down",])
    # print the numbers of DE genes
    DE_object@Number_DE_genes <- list(up_regulated_Genes = nrow(DE_object@DE_genes$up_regulated_Genes),
                                      down_regulated_Genes= nrow(DE_object@DE_genes$down_regulated_Genes))
    # write DE_object into results_list
    results_list[[paste(comparison_table$comparison[i], "vs", comparison_table$control[i], sep="_")]] <- DE_object
  }
  return(results_list)
}
```

### Union of DEgenes
```{r}
uDEG <- function(comparisons){
  uDEGs <- NULL
  tmp <- DEresults[names(DEresults) %in% comparisons]
  for(i in 1:length(comparisons)){
    DEGs <- as.data.frame(tmp[[i]]@results[tmp[[i]]@results$regulation %in% c("up","down"),])
    uDEGs <- unique(c(uDEGs, DEGs$GENEID))
  }
  uDEGs
}
```

### Venn Diagram
```{r}
plotVenn <- function(comparisons,
                     regulation=NULL){
  venn <- NULL
  for(i in 1:length(comparisons)){
    res <- DEresults[names(DEresults) %in% comparisons]
    comp <- as.data.frame(res[[i]]@results)
    if(is.null(regulation)){
      DE <- ifelse(comp$regulation %in% c("up","down"), 1, 0)
      venn <- cbind(venn, DE)
      colnames(venn)[i]<- paste(names(res)[[i]], "up&down", sep=": ")
    } else {
      DE <- ifelse(comp$regulation == regulation, 1, 0)
      venn <- cbind(venn, DE)
      colnames(venn)[i]<- paste(names(res)[[i]], regulation, sep=": ")
    }

  }
  vennDiagram(venn,cex = 1, counts.col = "blue")
}
```

### Ratio Plot
```{r}
plotRatios <- function(comp1, comp2){
  U <- NULL
  c <- c(comp1,comp2)
  U <- uDEG(c)
  Ratio <- NULL
  for(i in 1:length(c)){
    tmp <- DEresults[names(DEresults) %in% c]
    comp <- as.data.frame(tmp[[i]]@results)
    DE <- as.data.frame(comp[rownames(comp) %in% U,])
    Ratio <- as.data.frame(cbind(Ratio,DE$log2FoldChange))
  }
  colnames(Ratio)<- c
  rownames(Ratio) <- U
  ggplot(Ratio, aes(x=Ratio[,1], y=Ratio[,2])) +
    geom_point(colour = "grey", size = 1.5) + 
    theme_bw() +
    xlab(comp1)+
    ylab(comp2) +
    geom_abline(slope = c(-1,1),intercept = 0, colour="grey") +
    geom_hline(yintercept = c(0,log(2,2),-(log(2,2))))+
    geom_hline(yintercept = c(log(2,2),-(log(2,2))), colour="firebrick1")+
    geom_vline(xintercept = c(log(2,2),-(log(2,2))))+
    geom_vline(xintercept = c(log(2,2),-(log(2,2))), colour="firebrick1")+
    theme(text = element_text(size=10))+
    ggtitle(paste(comp1," vs ",comp2,": ",length(U)," DE genes",sep=""))
}
```

### Ranked Fold Change plot
```{r}
plotFCrank <- function(comp1,
                       comp2){
    rank <- na.omit(DEresults[names(DEresults) == comp1][[1]]@results)
    rank <- rank[rank$padj < 0.05 , c("GENEID","comparison","log2FoldChange")]
    rank <- rank[order(rank$log2FoldChange,decreasing = TRUE),]
    rank$rank <- c(1:nrow(rank))
    rank2 <- DEresults[names(DEresults) == comp2][[1]]@results
    rank2 <- rank2[rownames(rank),c("GENEID","comparison","log2FoldChange")]
    rank2$rank <- rank$rank 
    rank <- rbind(rank, rank2)

    ggplot(rank,aes(x=rank,y=log2FoldChange,color=comparison)) +
      geom_point(alpha=0.5) +
      geom_line(aes(group=GENEID),color="grey",alpha=0.2)+
      theme_bw() +
      ylab("log2(FoldChange)")+
      xlab(paste("FC rank of " ,comp1, sep=""))+
      geom_hline(yintercept = 0)+
      geom_hline(yintercept = c(log(2,2),-(log(2,2))), colour="firebrick1")+
      theme(text = element_text(size=10))+
      ggtitle("Comparison of fold changes (comp1 padj<0.05")+ 
      theme(legend.position="bottom")
}
```

### GO & KEGG enrichment across comparisons
```{r}
compareGSEA <- function(comparisons, 
                        organism, # chose organism
                        GeneSets =c("GO","KEGG"), # choose gene sets for enrichment
                        ontology= "BP", # define GO subset
                        pCorrection = "bonferroni", # choose the p-value adjustment method
                        pvalueCutoff = 0.05, # set the unadj. or adj. p-value cutoff (depending on correction method)
                        qvalueCutoff = 0.05, # set the q-value cutoff (FDR corrected)
                        showMax = 20){
  
  if(organism == "mouse") {
    OrgDb = org.Mm.eg.db
  } else if(organism == "human"){
      OrgDb = org.Hs.eg.db
    } else {stop("Wrong Organism. Select mouse or human.")}
  
  ENTREZlist <-  list()
  for(i in 1:length(comparisons)){
    res <- DEresults[names(DEresults) %in% comparisons]
    DE_up <- as.data.frame(res[[i]]@DE_genes$up_regulated_Genes)$SYMBOL
    entrez_up <- bitr(DE_up, fromType = "SYMBOL", toType="ENTREZID", OrgDb=OrgDb)$ENTREZID
    DE_down <- as.data.frame(res[[i]]@DE_genes$down_regulated_Genes)$SYMBOL
    entrez_down <- bitr(DE_down, fromType = "SYMBOL", toType="ENTREZID", OrgDb=OrgDb)$ENTREZID  
    x <- setNames(list(entrez_up, entrez_down),
                  c(paste(names(res[i]),"_up",sep=""), 
                    paste(names(res[i]),"_down",sep="")))
    ENTREZlist <- c(ENTREZlist,x)
  }
  
  list <- list()
  
  # Compare the Clusters regarding their GO enrichment  
  if("GO" %in% GeneSets){
    print("Performing GO enrichment")
    CompareClusters_GO <- compareCluster(geneCluster = ENTREZlist, 
                                       fun = "enrichGO",  
                                       universe = universe_Entrez,
                                       OrgDb = OrgDb,
                                       ont = ontology, 
                                       pvalueCutoff  = pvalueCutoff, 
                                       pAdjustMethod = pCorrection, 
                                       qvalueCutoff  = pvalueCutoff,  
                                       readable      = T)
    list$GOresults <- as.data.frame(CompareClusters_GO)
    list$GOplot <- clusterProfiler::dotplot(CompareClusters_GO, showCategory = showMax, by = "geneRatio", font.size=10)
  }
  
  if("KEGG" %in% GeneSets){
    print("Performing KEGG enrichment")
    
    if(organism == "mouse"){org = "mmu"} 
    if(organism == "human"){org = "hsa"}
    
    # Compare the Clusters regarding their KEGG enrichment  
    CompareClusters_KEGG <- compareCluster(geneCluster = ENTREZlist, 
                                         fun = "enrichKEGG",  
                                         universe = universe_Entrez,
                                         organism = org, 
                                         pvalueCutoff  = pvalueCutoff, 
                                         pAdjustMethod = pCorrection, 
                                         qvalueCutoff  = pvalueCutoff)
    list$KEGGresults <- as.data.frame(CompareClusters_KEGG)
    list$KEGGplot <- clusterProfiler::dotplot(CompareClusters_KEGG, showCategory = showMax, by = "geneRatio", font.size=10)
  }
  list
}
```

### Plot baseMean versus fold change (MAplot)
```{r}
plotMA <- function(comparison, 
                   ylim=c(-2,2),  
                   padjThreshold=0.05,
                   xlab = "mean of normalized counts", 
                   ylab = expression(log[2]~fold~change),
                   log = "x", 
                   cex=0.45){
  x <- as.data.frame(DEresults[[comparison]]@results)
  if (!(is.data.frame(x) && all(c("baseMean", "log2FoldChange") %in% colnames(x)))){
    stop("'x' must be a data frame with columns named 'baseMean', 'log2FoldChange'.")
  }
  col = ifelse(x$padj>=padjThreshold, "gray32", "red3")
  py = x$log2FoldChange
  if(missing(ylim)){
      ylim = c(-1,1) * quantile(abs(py[is.finite(py)]), probs=0.99) * 1.1
  }
  plot(x=x$baseMean, 
       y=pmax(ylim[1], pmin(ylim[2], py)),
       log=log, 
       pch=ifelse(py<ylim[1], 6, ifelse(py>ylim[2], 2, 16)),
       cex=cex, 
       col=col, 
       xlab=xlab, 
       ylab=ylab, 
       ylim=ylim,
       main=comparison)
  abline(h=0, lwd=4, col="#ff000080")
  abline(h=c(-1,1), lwd=2, col="dodgerblue")
}
```

### p-value distribution  
```{r}
plotPvalues <- function(comparison){
  res <- as.data.frame(DEresults[[comparison]]@results)
  ggplot(na.omit(res), aes(x=pvalue)) + 
      geom_histogram(aes(y=..count..),               
      binwidth = 0.01) +
      theme_bw()+
      ggtitle(paste("p value histogram of: ",comparison,sep=""))
}
```

### Heatmaps of DE genes based on pheatmap
```{r}
plotDEHeatmap <- function(input=norm_anno,
                               comparison,
                          factor,
                          conditions="all",
                          show_rownames = FALSE,
                          cluster_cols = FALSE,
                          font.size=7,
                          max.value=2){

  geneset <- DEresults[[comparison]]@results[DEresults[[comparison]]@results$regulation %in% c("up","down"),"GENEID"]
    
  input <- norm_anno[norm_anno$GENEID %in% geneset,]
  rownames(input) <- paste(input$GENEID, ":", input$SYMBOL, sep="")
  
  if(conditions[1] == "all"){
    input <- input[,colnames(input) %in% sample_table$ID]
    input_scale <- t(scale(t(input)))
    input_scale <- input_scale[,order(sample_table[[plot_order]], decreasing = FALSE)]
  } else {
    input <- input[,colnames(input) %in% sample_table[as.vector(sample_table[[factor]]) %in% conditions,]$ID,]
    input_scale <- t(scale(t(input)))
  }
  
  pheatmap(input_scale,
         main=paste("Heatmap of significant DE genes in: ",comparison,sep=""),
         show_rownames=show_rownames,
         show_colnames=TRUE,
         cluster_cols = cluster_cols, 
         fontsize = font.size,
         annotation_col = plot_annotation,
         annotation_colors = ann_colors,
         breaks = scaleColors(data = input_scale, maxvalue = max.value)[["breaks"]], 
         color = scaleColors(data = input_scale, maxvalue = max.value)[["color"]])
}
```

### Volcano Plot
```{r}
plotVolcano <-  function(comparison,
                         labelnum=20){
    
    # specify labeling    
    upDE <-  as.data.frame(DEresults[[comparison]]@results[DEresults[[comparison]]@results$regulation =="up",]) 
    FClabel_up <- upDE[order(abs(upDE$log2FoldChange), decreasing = TRUE),]
    if(nrow(FClabel_up)>labelnum){
      FClabel_up <- as.character(FClabel_up[c(1:labelnum),"GENEID"])
    } else {
        FClabel_up <- as.character(FClabel_up$GENEID)}
    plabel_up <- upDE[order(upDE$padj, decreasing = FALSE),]
    if(nrow(plabel_up)>labelnum){
      plabel_up <- as.character(plabel_up[c(1:labelnum),"GENEID"])
    } else {
        plabel_up <- as.character(plabel_up$GENEID)}
    
    downDE <-  as.data.frame(DEresults[[comparison]]@results[DEresults[[comparison]]@results$regulation =="down",]) 
    FClabel_down <- downDE[order(abs(downDE$log2FoldChange), decreasing = TRUE),]
    if(nrow(FClabel_down)>labelnum){
      FClabel_down <- as.character(FClabel_down[c(1:labelnum),"GENEID"])
    } else {
        FClabel_down <- as.character(FClabel_down$GENEID)}
    plabel_down <- downDE[order(downDE$padj, decreasing = FALSE),]
    if(nrow(plabel_down)>labelnum){
      plabel_down <- as.character(plabel_down[c(1:labelnum),"GENEID"])
    } else {
        plabel_down <- as.character(plabel_down$GENEID)}
    
    
    label<- unique(c(FClabel_up, plabel_up, FClabel_down, plabel_down))
    
    data <- DEresults[[comparison]]@results
    data$label<- ifelse(data$GENEID %in% label == "TRUE",as.character(data$SYMBOL), "")
    
    # Volcano Plot
    ggplot(data=na.omit(data), aes(x=log2FoldChange, y=-log10(padj), colour=regulation)) +
      geom_point(alpha=0.4, size=1.75) +
      scale_color_manual(values=c("cornflowerblue","grey", "firebrick"))+
      scale_x_continuous() +
      scale_y_continuous() +
      xlab("log2(FoldChange)") +
      ylab("-log10(padj)") +
      geom_vline(xintercept = 0, colour="black")+
      geom_vline(xintercept = c(-log(2,2),log(2,2)), colour="red")+
      geom_hline(yintercept=-log(0.05,10),colour="red")+
      geom_text_repel(data=na.omit(data[!data$label =="",]),aes(label=label), size=3)+
      guides(colour=FALSE) + 
      ggtitle(paste("Volcano Plot of: ",comparison,sep="")) +
      theme_bw()
}
```


### GSEA function
```{r}
GSEA <-  function(comparison,
                   organism,
                   GeneSets =c("GO","KEGG","DO","Hallmark","cannonicalPathways","Motifs","ImmunoSignatures"),
                   GOntology = "BP",
                   pCorrection = "bonferroni", # choose the p-value adjustment method
                   pvalueCutoff = 0.05, # set the unadj. or adj. p-value cutoff (depending on correction method)
                   qvalueCutoff = 0.05 # set the q-value cutoff (FDR corrected)
){
  
  results <- list()
  
  if(organism == "mouse") {
    OrgDb = org.Mm.eg.db
  } else if(organism == "human"){
    OrgDb = org.Hs.eg.db
  } else {print("Wrong Organism. Select mouse or human.")}
  
  res <- DEresults[[comparison]]
  DE_up <- as.data.frame(res@DE_genes$up_regulated_Genes)$SYMBOL
  entrez_up <- bitr(DE_up, fromType = "SYMBOL", toType="ENTREZID", OrgDb=OrgDb)$ENTREZID
  DE_down <- as.data.frame(res@DE_genes$down_regulated_Genes)$SYMBOL
  entrez_down <- bitr(DE_down, fromType = "SYMBOL", toType="ENTREZID", OrgDb=OrgDb)$ENTREZID  
  
  # GO enrichment
  if("GO" %in% GeneSets){
    print("Performing GO enrichment")
    if(length(entrez_up)<20){
      print("Too few upregulated genes for GO enrichment (<20)")
      results$GOup <- "Too few upregulated genes for GO enrichment (<20)"
    }else{
      results$GOup <- as.data.frame(enrichGO(gene = entrez_up,
                                             universe = universe_Entrez,
                                             OrgDb = OrgDb,
                                             ont = GOntology,
                                             pAdjustMethod = pCorrection,
                                             pvalueCutoff  = pvalueCutoff,
                                             qvalueCutoff  = qvalueCutoff,
                                             readable      = T))
      
      if(nrow(results$GOup)>0){results$GOup$Enrichment <- paste("GO enrichment for genes upregulated in ",comparison,sep="")}
    }
    if(length(entrez_down)<20){
      print("Too few downregulated genes for GO enrichment (<20)")
      results$GOdown <- "Too few downregulated genes for GO enrichment (<20)"
    }else{
      results$GOdown <- as.data.frame(enrichGO(gene = entrez_down,
                                               universe = universe_Entrez,
                                               OrgDb = OrgDb,
                                               ont = GOntology,
                                               pAdjustMethod = pCorrection,
                                               pvalueCutoff  = pvalueCutoff,
                                               qvalueCutoff  = qvalueCutoff,
                                               readable      = T))
      if(nrow(results$GOdown)>0){results$GOdown$Enrichment <- paste("GO enrichment for genes downregulated in ",comparison,sep="")}
    }
  }
  
  # KEGG enrichment
  if("KEGG" %in% GeneSets){
    print("Performing KEGG enrichment")
    
    if(organism == "mouse") {org = "mmu"} 
    if(organism == "human"){org = "hsa"}
    
    if(length(entrez_up)<20){
      print("Too few upregulated genes for KEGG enrichment (<20)")
      results$KEGGup <- "Too few upregulated genes for KEGG enrichment (<20)"
    }else{
      results$KEGGup <- as.data.frame(enrichKEGG(gene = entrez_up, 
                                                  organism = org,
                                                  universe = universe_Entrez, 
                                                  pAdjustMethod = pCorrection,
                                                  pvalueCutoff  = pvalueCutoff,
                                                  qvalueCutoff = qvalueCutoff))
      if(nrow(results$KEGGup)>0){results$KEGGup$Enrichment <- paste("KEGG enrichment for genes upregulated in ",comparison,sep="")}
    }
    if(length(entrez_down)<20){
      print("Too few downregulated genes for KEGG enrichment (<20)")
      results$KEGGdown <- "Too few downregulated genes for KEGG enrichment (<20)"
    } else{
      results$KEGGdown <- as.data.frame(enrichKEGG(gene = entrez_down, 
                                                   organism = org,
                                                   universe = universe_Entrez, 
                                                   pAdjustMethod = pCorrection,
                                                   pvalueCutoff  = pvalueCutoff,
                                                   qvalueCutoff = qvalueCutoff))
      if(nrow(results$KEGGdown)>0){results$KEGGdown$Enrichment <- paste("KEGG enrichment for genes downregulated in ",comparison,sep="")}
    }
  }
  
  if("Hallmark" %in% GeneSets |
     "DO" %in% GeneSets |
     "cannonicalPathways" %in% GeneSets| 
     "ImmunoSignatures" %in% GeneSets | 
     "Motifs" %in% GeneSets){
    if(organism=="mouse"){
      entrez_up_hsa <- as.character(getLDS(attributes = c("mgi_symbol"), 
                                           filters = "mgi_symbol", 
                                           values = DE_up, 
                                           mart = useMart("ensembl", dataset = "mmusculus_gene_ensembl"),
                                           attributesL = c("entrezgene"), 
                                           martL = useMart("ensembl", dataset = "hsapiens_gene_ensembl"),
                                           uniqueRows=T)[,2])
      
      entrez_down_hsa <- getLDS(attributes = c("mgi_symbol"), 
                                filters = "mgi_symbol", 
                                values = DE_down, 
                                mart = useMart("ensembl", dataset = "mmusculus_gene_ensembl"), 
                                attributesL = c("entrezgene"), 
                                martL = useMart("ensembl", dataset = "hsapiens_gene_ensembl"), 
                                uniqueRows=T)[,2]
    }
    if(organism=="human"){
      entrez_up_hsa <- entrez_up
      entrez_down_hsa <- entrez_down
    }
  }
  
  # DO enrichment
  if("DO" %in% GeneSets){
    print("Performing Disease Ontology enrichment")
    
    if(length(entrez_up)<20){
      print("Too few upregulated genes for DO enrichment (<20)")
      results$DOup <- "Too few upregulated genes for DO enrichment (<20)"
    }else{
      results$DOup <- as.data.frame(enrichDO(gene = entrez_up_hsa, 
                                             universe = universe_mouse2human_Entrez, 
                                             pAdjustMethod = pCorrection,
                                             pvalueCutoff  = pvalueCutoff,
                                             qvalueCutoff = qvalueCutoff,
                                             minGSSize     = 5,
                                             maxGSSize     = 500,
                                             readable=TRUE))
      if(nrow(results$DOup)>0){results$DOup$Enrichment <- paste("DO enrichment for genes upregulated in ",comparison,sep="")}
    }
    if(length(entrez_down)<20){
      print("Too few downregulated genes for DO enrichment (<20)")
      results$DOdown <- "Too few downregulated genes for DO enrichment (<20)"
    } else{
      results$DOdown <- as.data.frame(enrichDO(gene = entrez_down_hsa, 
                                               universe = universe_mouse2human_Entrez, 
                                               pAdjustMethod = pCorrection,
                                               pvalueCutoff  = pvalueCutoff,
                                               qvalueCutoff = qvalueCutoff,
                                               minGSSize     = 5,
                                               maxGSSize     = 500,
                                               readable=TRUE))
      if(nrow(results$DOdown)>0){results$DOdown$Enrichment <- paste("DO enrichment for genes downregulated in ",comparison,sep="")}
    }
  }
  
  # Hallmark enrichment
  if("Hallmark" %in% GeneSets){
    print("Performing Hallmark enrichment")
    if(length(entrez_up_hsa)<20){
      print("Too few upregulated genes for Hallmark enrichment (<20)")
      results$Hallmarkup <- "Too few upregulated genes for Hallmark enrichment (<20)"
    }else{
      results$HALLMARKup <- as.data.frame(enricher(entrez_up_hsa,
                                                   TERM2GENE=hallmark_genes,
                                                   universe = universe_mouse2human_Entrez,  
                                                   pAdjustMethod = pCorrection,
                                                   pvalueCutoff  = pvalueCutoff,
                                                   qvalueCutoff = qvalueCutoff))
      if(nrow(results$HALLMARKup)>0){results$HALLMARKup$Enrichment <- paste("HALLMARK enrichment for genes upregulated in ",comparison,sep="")}
    }
    if(length(entrez_down_hsa)<20){
      print("Too few downregulated genes for Hallmark enrichment (<20)")
      results$Hallmarkdown <- "Too few downregulated genes for Hallmark enrichment (<20)"
    }else{
      results$HALLMARKdown <- as.data.frame(enricher(entrez_down_hsa,
                                                     TERM2GENE=hallmark_genes,
                                                     universe = universe_mouse2human_Entrez,  
                                                     pAdjustMethod = pCorrection,
                                                     pvalueCutoff  = pvalueCutoff,
                                                     qvalueCutoff = qvalueCutoff))
      if(nrow(results$HALLMARKdown)>0){results$HALLMARKdown$Enrichment <- paste("HALLMARK enrichment for genes downregulated in ",comparison,sep="")}
    }
  }
  
  # Cannonical Pathway enrichment
  if("cannonicalPathways" %in% GeneSets){
    print("Performing Cannonical Pathway (C2) enrichment")
    if(length(entrez_up_hsa)<20){
      print("Too few upregulated genes for Cannonical Pathway enrichment (<20)")
      results$cannonicalPathwaysup <- "Too few upregulated genes for Motif enrichment (<20)"
    }else{
      results$cannonicalPathwaysup <- as.data.frame(enricher(entrez_up_hsa,
                                                             TERM2GENE=cannonicalPathway_genes,
                                                             universe = universe_mouse2human_Entrez,  
                                                             pAdjustMethod = pCorrection,
                                                             pvalueCutoff  = pvalueCutoff,
                                                             qvalueCutoff = qvalueCutoff))
      if(nrow(results$cannonicalPathwaysup)>0){results$cannonicalPathwaysup$Enrichment <- paste("Cannonical pathway enrichment for genes upregulated in ",comparison,sep="")}
    }
    if(length(entrez_down_hsa)<20){
      print("Too few downregulated genes for cannonical pathway  enrichment (<20)")
      results$cannonicalPathwaysdown <- "Too few downregulated genes for cannonical pathway enrichment (<20)"
    }else{
      results$cannonicalPathwaysdown <- as.data.frame(enricher(entrez_down_hsa,
                                                               TERM2GENE=cannonicalPathway_genes,
                                                               universe = universe_mouse2human_Entrez,  
                                                               pAdjustMethod = pCorrection,
                                                               pvalueCutoff  = pvalueCutoff,
                                                               qvalueCutoff = qvalueCutoff))
      if(nrow(results$cannonicalPathwaysdown)>0){results$cannonicalPathwaysdown$Enrichment <- paste("Cannonical pathway enrichment for genes downregulated in ",comparison,sep="")}
    }
  }
  
  # Motif enrichment
  if("Motifs" %in% GeneSets){
    print("Performing Motif enrichment")
    if(length(entrez_up_hsa)<20){
      print("Too few upregulated genes for Motif enrichment (<20)")
      results$Motifup <- "Too few upregulated genes for Motif enrichment (<20)"
    }else{
      results$Motifup <- as.data.frame(enricher(entrez_up_hsa,
                                                TERM2GENE=motifs,
                                                universe = universe_mouse2human_Entrez,  
                                                pAdjustMethod = pCorrection,
                                                pvalueCutoff  = pvalueCutoff,
                                                qvalueCutoff = qvalueCutoff))
      if(nrow(results$Motifup)>0){results$Motifup$Enrichment <- paste("TF binding motif enrichment for genes upregulated in ",comparison,sep="")}
    }
    if(length(entrez_down_hsa)<20){
      print("Too few downregulated genes for Motif enrichment (<20)")
      results$Motifdown <- "Too few downregulated genes for Motif enrichment (<20)"
    }else{
      results$Motifdown <- as.data.frame(enricher(entrez_down_hsa,
                                                  TERM2GENE=motifs,
                                                  universe = universe_mouse2human_Entrez,  
                                                  pAdjustMethod = pCorrection,
                                                  pvalueCutoff  = pvalueCutoff,
                                                  qvalueCutoff = qvalueCutoff))
      if(nrow(results$Motifdown)>0){results$Motifdown$Enrichment <- paste("TF binding motif enrichment for genes downregulated in ",comparison,sep="")}
    }
  }
  
  # Immunosignatures enrichment
  if("ImmunoSignatures" %in% GeneSets){
    print("Performing immunesignature enrichment")
    if(length(entrez_up_hsa)<20){
      print("Too few upregulated genes for Immunosignature enrichment (<20)")
      results$ImmSigup <- "Too few upregulated genes for Immunosignature enrichment (<20)"
    }else{
      results$ImmSigup <- as.data.frame(enricher(entrez_up_hsa,
                                                 TERM2GENE=immuno_genes,
                                                 universe = universe_mouse2human_Entrez,  
                                                 pAdjustMethod = pCorrection,
                                                 pvalueCutoff  = pvalueCutoff,
                                                 qvalueCutoff = qvalueCutoff))
      if(nrow(results$ImmSigup)>0){results$ImmSigup$Enrichment <- paste("Immunosignature enrichment for genes upregulated in ",comparison,sep="")}
    }
    if(length(entrez_down_hsa)<20){
      print("Too few downregulated genes for Immunosignature enrichment (<20)")
      results$ImmSigdown <- "Too few downregulated genes for Immunosignature enrichment (<20)"
    }else{
      results$ImmSigdown <- as.data.frame(enricher(entrez_down_hsa,
                                                   TERM2GENE=immuno_genes,
                                                   universe = universe_mouse2human_Entrez,  
                                                   pAdjustMethod = pCorrection,
                                                   pvalueCutoff  = pvalueCutoff,
                                                   qvalueCutoff = qvalueCutoff))
      if(nrow(results$ImmSigdown)>0){results$ImmSigdown$Enrichment <- paste("Immunosignature enrichment for genes downregulated in ",comparison,sep="")}
    }
  }
  results
}
```

### GSEA dotplot
```{r}
dotplotGSEA <- function(x,
                        show=25,
                        font.size=10,
                        title.size=10,
                        title.width=100,
                        order="count"){
  if(nrow(x)<1){
    print("No enrichment found.")
  }else{
    x <- if(nrow(x)>show){x[c(1:show),]}else{x}
    if(order=="padj"){
    x <- x[order(x$Count,decreasing=FALSE),]
    x$GeneRatio <- factor(x$GeneRatio, levels = unique(x$GeneRatio))
    x <- x[order(x$p.adjust,decreasing=TRUE),]
    x$Description <- factor(x$Description, levels = unique(x$Description))
    }
    if(order=="count"){
    x <- x[order(x$Count,decreasing=FALSE),]
    x$Description <- factor(x$Description, levels = unique(x$Description))
    x$GeneRatio <- factor(x$GeneRatio, levels = unique(x$GeneRatio))
    }
    ggplot(x, aes(x = GeneRatio, y = Description, color = p.adjust)) +
      geom_point(aes(size = Count)) +
      scale_colour_gradientn(colours=c('red', 
                                       'orange', 
                                       'darkblue',
                                       'darkblue'),
                             limits=c(0,1),
                             values   = c(0,0.05,0.2,0.5,1),
                             breaks   = c(0.05,0.2,1),
                             labels = format(c(0.05,0.2,1))) +
      ylab(NULL) +
      ggtitle(paste(strwrap(unique(x$Enrichment), width=title.width), collapse = "\n"))+
      theme_bw() +
      theme(text = element_text(size=font.size),
            plot.title = element_text(size=title.size)) 
  }
}
```

### Heatmap of genes responsible for gene set enrichment
```{r global functions, hide = T}
plotGSEAHeatmap<-function(input=norm_anno,
                               GSEA_result,
                          GeneSet, 
                          term,
                          organism,
                          show_rownames = TRUE,
                          cluster_cols = FALSE,
                          regulation,
                          font.size=7,
                          max.value=2){
  xterm <- paste("^", term, "$", sep="") 
  tmp <- GSEA_result[grep(xterm,GSEA_result$Description),]
  gene.list <- unique(unlist(strsplit(tmp$geneID, split = "/")))
  
  if(organism == "mouse") {
    OrgDb = org.Mm.eg.db
  } else if(organism == "human"){
    OrgDb = org.Hs.eg.db
  } else {print("Wrong Organism. Select mouse or human.")}
  
  if(GeneSet == "KEGG"){
    gene.list <- bitr(gene.list, 
                      fromType = "ENTREZID", 
                      toType="SYMBOL", 
                      OrgDb=OrgDb)[,2]
  }
  
  if(GeneSet == "HALLMARK" |GeneSet == "DO" | GeneSet == "ImmunoSignatures" | GeneSet == "cannonicalPathways" | GeneSet == "Motifs"){
    if(organism == "mouse") {
      gene.list <- getLDS(attributes = c("entrezgene"), 
                          filters = "entrezgene", 
                          values = gene.list, 
                          mart = useMart("ensembl", dataset = "hsapiens_gene_ensembl"), 
                          attributesL = c("mgi_symbol"), 
                          martL = useMart("ensembl", dataset = "mmusculus_gene_ensembl"),
                          uniqueRows=T)[,2]
    }else if(organism == "human"){
      gene.list <- bitr(gene.list, 
                      fromType = "ENTREZID", 
                      toType="SYMBOL", 
                      OrgDb=OrgDb)[,2]
    }
  }
  
  plotHeatmap(input=input,geneset = gene.list,
              keyType = "Symbol",
              title = paste("Heatmap of genes responsible for enrichment of term: ",term,", in ",deparse(substitute(GSEA_result)),sep=""),
              show_rownames = show_rownames,
              cluster_cols = cluster_cols,
              font.size=font.size,
              max.value=max.value)
}
```

# 2. Project information

*Please specify important information on the data set.*

* Scienfitic question: 

* IDs: 
* Samples: 
* Conditions:
* Species:
* Cell type(s):

* RNA-isolation: 
* Library-Production: 
* Sequencing method:
* Sequencing run(s): 
* Alignment: 
* QC: 

* Project directories on Illumina: 
* Project directory on blades: 

**Workflow Summary:**

*Space for notes concerning the global workflow and quality checks.*

## Set project directory 

**Obligatory structure of your directory:**

The project directory needs to contain a folder */Data*, which contains: 

1) The output folder of the bulk RNAseq Kallisto pipeline including the folders *kallisto* and *qc* 
  * The kallisto output files should be in: *Data/output/kallisto/kallisto/*
  * The Quality Control files should be in: 
      *Data/output/kallisto/mutiqc/multiqc_data/multiqc_kallisto.txt* and 
      *Data/output/qc/multiqc/multiqc_data/multiqc_fastqc.txt*. 

2) A sample table:  *sample_table.txt*, which should contain *at least* the following columns: 
  * Sample Identifier (e.g. 3609): "ID"
  * Sample Name (e.g. wt_8mo_5870): "sample_name"
  * Condition (e.g. wt_8mo): "condition"   --> merged sample information that is used for DE calling 
  * Optional additional information: gender, age, date of experiment, ... 

3) A gene annotation file (produced from the gtf file used for buildig the kallisto index).
  * mouse: ID2SYMBOL_gencode_vM*X*_transcript.txt
  * human: ID2SYMBOL_gencode_v*X*_transcript.txt

4) A folder *GMTfiles* containing gene set annotation, incl. GO, KEGG, and the MSigDB (http://software.broadinstitute.org/gsea/msigdb) data sets: hallmark, motif and immunological gene sets

*ATTENTION:* The gene annotation files as well as the GMT files for human and mouse can be downloaded here: 
https://uni-bonn.sciebo.de/s/MizDdMdLYmFh7QX

**Specify the organism of the data set**

```{r}
organism = "mouse" # choose "mouse" or "human"
```


**Specify the project directory here:**

```{r, warning=F}
dir <- "C:/Users/reusch.n/sciebo/DESeq2_pipeline"

# creating output directories (if not already existing):
dir.create(file.path(dir, "Analysis", "Tables"), recursive = T)
dir.create(file.path(dir, "Analysis", "Plots"), recursive = T)
```

# 3. Data Import

## Load gene annotation

This gene annotation file will be used 
  1) to map the Ensembl transcript IDs to Ensembl gene IDs during the tximport function and 
  2) annotate the Ensembl IDs with additional information such as gene symbol or type.
  
For consistency, this file should have been produced from the .gtf file used for building the kallisto index. It needs to consist of four columns: Gene ENSEMBL ID, Transcript ID, Gene Symbol, Gene Type.

```{r gene annotation import}
# Specify the filename of your gene annotation file here: 
annotation_filename <- "ID2SYMBOL_gencode_vM13_transcript.txt"

tx_annotation <- read.delim(file.path(dir, "Data", annotation_filename), 
                         header = F , 
                         stringsAsFactors = F,
                         col.names = c("GENEID", "TXNAME", "SYMBOL", "GENETYPE"))
```

## Load gene set annotation
```{r}
# Transcrption Factors
# read mouse TF list
TFlist_mm <-read.csv(file.path(dir, "Data/GMTfiles/20180317_TFlist_mouse_TFdb_riken.csv", sep=""), 
                       stringsAsFactors = FALSE, 
                       header = FALSE)[,1]
# read human TF list
TFlist_hs <- read.csv(file.path(dir, "Data/GMTfiles/20180317_TFlist_human_Lambert_Cell2018.csv", sep=""),
                       stringsAsFactors = FALSE, 
                       header = FALSE)[,1]
# GO
GO_mm <- read.delim(file.path(dir, "Data/GMTfiles/GO_mm38p12_ensembl181121.txt"),header=TRUE,stringsAsFactors = FALSE,quote="")
GO_hs <- read.delim(file.path(dir, "Data/GMTfiles/GO_hg38p12_ensembl181121.txt"),header=TRUE,stringsAsFactors = FALSE,quote="")
# KEGG
KEGG_mm <- read.delim(file.path(dir, "Data/GMTfiles/KEGG_mm10_clusterProfiler181121.txt"),header=TRUE,stringsAsFactors = FALSE)
KEGG_hs <- read.delim(file.path(dir, "Data/GMTfiles/KEGG_hg38_clusterProfiler181121.txt"),header=TRUE,stringsAsFactors = FALSE)
# MiSigDB gene sets
hallmark_genes <- clusterProfiler::read.gmt(file.path(dir, "Data/GMTfiles/h.all.v6.2.entrez.gmt"))
cannonicalPathway_genes <- clusterProfiler::read.gmt(file.path(dir, "Data/GMTfiles/c2.cp.v6.2.entrez.gmt"))
immuno_genes <- clusterProfiler::read.gmt(file.path(dir, "Data/GMTfiles/c7.all.v6.2.entrez.gmt"))
motifs <- clusterProfiler::read.gmt(file.path(dir, "Data/GMTfiles/c3.all.v6.2.entrez.gmt"))
```

## Load sample table

Now, we read a table containing all available metainformation for the samples. This table needs to be prepared beforehand from information on the sequencing tracker or provided by the experimental partners.

```{r sample table import}
sample_table <- read.delim(file.path(dir, "Data", "sample_table.txt"))
rownames(sample_table) <- sample_table$ID
sample_table
```

### Format sample table

For the correct order of the samples in later plots, we define the column of our sample table that contains the information of interest and reorder its factor levels.

```{r colour definitions}
## Add columns with factors for comparisons in model
sample_table$Genotype_Age <- factor(sample_table$Genotype_Age,
                                   levels = c("wt_4mo", "wt_8mo", "wt_12mo", "tg_4mo", "tg_8mo","tg_12mo"))

sample_table$Age <- factor(sample_table$Age, 
                           levels = c("4mo", "8mo", "12mo"))

# order according to factor of interest
sample_table <- sample_table[order(sample_table$Genotype_Age),]

# define factor for order of samples in plotting 
plot_order <- "Genotype_Age"
```

### Colour scheme customization

Define you colour schemes according to your data set and your variables!

For hex colors use: https://www.color-hex.com

```{r}
# Genotype
col_genotype <- c("#81c354", "#86BE9E")
names(col_genotype) <- c("wt", "tg") 
# Age
col_age = c("#FFEDA0", "#FEB24C", "#F03B20")
names(col_age) <- c("4mo", "8mo", "12mo")
# Sex
col_sex <- c("##66C3D0", "#008DD2")
names(col_sex) <- c("f", "m")
# merged: Genotype and Age
col_genotype_age <- c(brewer.pal(3, "Blues"), brewer.pal(3, "Oranges"))
names(col_genotype_age) <- c("wt_4mo", "wt_8mo", "wt_12mo", "tg_4mo", "tg_8mo", "tg_12mo")

# combine color code into list
ann_colors <- list(Genotype = col_genotype, 
                  Age = col_age, 
                  Sex = col_sex,
                  Genotype_Age = col_genotype_age)
```


## Quality check

The following visualizations of the data quality check results are only an addition to the much more comprehensive quality plots provided in the MultiQC .html files. 

**Please check the multiQC output thoroughly before you perfrom any analysis.**

### Fastq QC

Read and visualize fastQC MultiQC output. 

For many projects, multiple sequencing runs are necessary to get a satisfactory sequencing depth for all samples. Furthermore, samples can be distributed onto multiple lanes of a flowcell.Since the quality of each single run and lane can differ, we want to look at all fastq files from all runs and lanes seperately.

For more information on fastQC, please check: https://www.bioinformatics.babraham.ac.uk/projects/fastqc/

```{r MultiQC import}
fastq_qc <- read.delim(file.path(dir, "Data", "output", "qc", "multiqc", "multiqc_data",
                                 "multiqc_fastqc.txt"),
                       stringsAsFactors = F)

fastq_qc$ID <- unlist(lapply(strsplit(fastq_qc$Sample, split = "_"), `[[`, 7)) # sample identifiers
fastq_qc$run <- unlist(lapply(strsplit(fastq_qc$Sample, split = "_"), `[[`, 2)) # run identifiers
fastq_qc$lane <- unlist(lapply(strsplit(fastq_qc$Sample, split = "_"), `[[`, 9)) # lane identifiers

rownames(fastq_qc) <- paste(fastq_qc$run, fastq_qc$ID, fastq_qc$lane, sep = "_")
```

Visualization: **Heatmap of fastQC quality checks**

```{r, fig.height=8, fig.width=10}
fastQC_HC <- t(fastq_qc[,colnames(fastq_qc) %in% c("per_base_sequence_quality",
                                              "per_sequence_quality_scores",
                                              "per_base_sequence_content",
                                              "per_sequence_gc_content",
                                              "per_base_n_content",
                                              "sequence_length_distribution",
                                              "sequence_duplication_levels",
                                              "overrepresented_sequences",
                                              "adapter_content")])

draw(Heatmap(fastQC_HC,
        c("firebrick2", "forestgreen", "goldenrod1"),
        column_title = "FastQC results"),
     heatmap_legend_side = "left")
```


### Kallisto QC
Read  and visualize kallisto MultiQC output.

Before alignment, multiple fastq files from multiple lanes or runs for a single sample are merged and aligned as one sample. Thus, we have only one alignment score per sample. 

Since we want to later visualize the alignment statistics in analysis plots, we add this information to our sample table.

```{r Kallisto QC import}
kallisto_qc <- read.delim(file.path(dir, "Data", "output", "kallisto", "multiqc", "multiqc_data", "multiqc_kallisto.txt"), stringsAsFactors = F)

# change sample column 
kallisto_qc$Sample <- do.call(rbind, strsplit(kallisto_qc$Sample, split = "\\_"))[,1]

# Merge kallisto QC to sample table
sample_table <- merge(sample_table, kallisto_qc, by.x = "ID", by.y = "Sample")
```

Visualization of pseudoaligned and total reads:

```{r}
alignstat <-sample_table[,c("ID", "pseudoaligned_reads","total_reads")]
alignstat <-gather(alignstat, "total_reads", "pseudoaligned_reads", key = "type", value = "reads")

ggplot(alignstat, aes(x = reorder(ID,-reads), y = reads, fill = type)) + 
  geom_bar(stat = "identity", position = "dodge", colour = "black") + 
  scale_y_continuous(breaks = c(c(5 , 10, 25, 50, 100) * 10^6))+
  scale_fill_manual(name = "", values = c("white", "grey")) + 
  ylab("Reads") + 
  xlab("Sample IDs") + 
  geom_hline(yintercept=5 * 10^6, linetype="dashed", color = "red") +
  ggtitle("Total reads and pseudoaligned reads") +
  theme(axis.text.x = element_text(angle = 70, size = 9, hjust = 1, vjust = 1), 
        strip.background = element_rect(fill = "white"), 
        panel.background = element_rect(fill = "white", colour = "black"), 
        legend.position = "bottom"
  )
```

```{r, echo=FALSE}
rm(alignstat)
```


### Exclude samples after QC (based e.g. on number of unique alignments, percent of aligned reads?)

In case, the data set contains samples of poor quality or simply to few reads, we might want to exclude these samples. In the following chunks, all samples with less than 5.000.000 reads are excluded from the subsequent analysis.

```{r qc sample exclusion}
# define read cutoff
samples_to_keep <- sample_table[sample_table$pseudoaligned_reads > 5000000,]$ID

# make reduced sampleTable file 
sample_table <- sample_table[which(sample_table$ID %in% samples_to_keep),]
rownames(sample_table) <- sample_table$ID
```

# 4. TXimport

A new and recommended pipeline for RNA-seq analysis is to use fast transcript abundance quantifiers, such as kallisto or Salmon, upstream of DESeq2, and then to create gene-level count matrices for use with DESeq2 by importing the quantification data using the tximport package.

We use tximport and DESeq2 based on the gene-level estimated counts from Kallisto (Bray, Pimentel, Melsted, Pachter 2016). 

Some advantages of using this methods for transcript abundance estimation are: 

  * this approach corrects for potential changes in gene length across samples (e.g. from differential isoform usage) (Trapnell et al. 2013), 
  * some of these methods (Salmon, Sailfish, kallisto) are substantially faster and require less memory and disk usage compared to alignment-based methods that require creation and storage of BAM files, and,
  * it is possible to avoid discarding those fragments that can align to multiple genes with homologous sequence, thus increasing sensitivity (Robert and Watson 2015).

Full details on the motivation and methods for importing transcript level abundance and count estimates, summarizing to gene-level count matrices and producing an offset which corrects for potential changes in average transcript length across samples are described in (Soneson, Love, and Robinson 2015). Note that the tximport-to-DESeq2 approach uses estimated gene counts from the transcript abundance quantifiers, but not normalized counts.

TXimport imports transcript-level abundance, estimated counts and transcript lengths, and summarizes these into matrices for use with downstream statistical analysis packages such as edgeR, DESeq2, limma-voom. 
Average transcript length, weighted by sample-specific transcript abundance estimates, is provided 
as a matrix, which is then used as an offset for different expression of gene-level counts.

```{r kallisto import}
# Define path where the Kallisto files are stored
files <- paste(dir, "/Data/output/kallisto/kallisto/", sample_table$ID, "/abundance.h5", sep = "")
# Naming the entries in the vector assures correct column names in the expression tables
names(files) <- sample_table$ID
# Import samples and perform the distribution of transcripts to genes
txi_kallisto <- tximport(files, 
                         type="kallisto", 
                         tx2gene=tx_annotation[,2:1])
```

# 5. Building the DESeqDataSet

The object class used by the DESeq2 package to store the read counts and the intermediate estimated quantities during statistical analysis is the DESeqDataSet, which will usually be represented in the code here as an object called "dds". 

A DESeqDataSet object must have an associated design formula. The design formula expresses the variables which will be used in modeling. The formula should be a tilde (~) followed by the variables with plus signs between them (it will be coerced into a formula if it is not already). The design can be changed later, however then all differential analysis steps should be repeated, as the design formula is used to estimate the dispersions and to estimate the log2 fold changes of the model.

```{r DESeqDatasetFromTXimport}
dds_txi <- DESeqDataSetFromTximport(txi = txi_kallisto, 
                                    colData = sample_table,
                                    design = ~ Genotype_Age)
```

## Pre-filtering

While it is not necessary to pre-filter low count genes before running the DESeq2 functions, there are two reasons which make pre-filtering useful: 
  * by removing rows in which there are very few reads, we reduce the memory size of the dds data object, and 
  * we increase the speed of the transformation and testing functions within DESeq2. 

Here, we perform a minimal pre-filtering to keep only rows that have at least 10 reads total. 

*Note that more strict filtering to increase power is automatically applied via independent filtering or independent hypothesis weighting on the mean of normalized counts within the results function.*

```{r pre-filtering}
genes_to_keep <- rowSums(counts(dds_txi)) >= 10
dds <- dds_txi[genes_to_keep,]
```

**Number of genes after filtering is:** `r sum(genes_to_keep) `

## DESeq calculations

**DESeq2:** Estimate variance-mean dependence (2) in count data from high-throughput sequencing assays and test for differential expression based on a model using the negative binomial distribution (1).

1) In inferential testing a distributional assumption is needed because we want to estimate the probability of extreme events just appearing by chance (e.g. large fold change) from limited replicates. The test statistic of ANOVA (or t-test) follows a Student's t distribution, a specific case of the normal distribution. However, counts, as produced in RNA-seq experiments, cannot be normally distributed by definition(you can't have -3 counts, or 12.2 counts). Two distributions for count based data are Poisson, which presumes that the variance and mean are equal, or negative binomial, a.k.a. Gamma-Poisson, which does not. The spread of values among biological replicates is more than given by the one parameter Poisson distribution and it seems to be captured by the two parameter (mean & variance) NB sufficiently well.

2) Information sharing across genes for variance estimation:  
In order to test the differential expression of a gene, we need to estimate its mean and variance for the underlying negative binomial distribution. Inferential methods that treat each gene separately suffer from the high uncertainty of within-group variance estimates. However, this limitation can be overcome by pooling information across genes, specifically, by exploiting assumptions about the similarity of the variances of different genes measured in the same experiment . DESeq2 detects and corrects dispersion estimates through modeling of the dependence of the dispersion on the average mean over all samples.

The standard differential expression analysis steps are wrapped into a single function, DESeq(). The estimation steps performed by this function are described in the manual page for ?DESeq and in the Methods section of the DESeq2 publication (Love, Huber, and Anders 2014).

This function performs a default analysis through the steps:

  1. Estimation of size factors: estimateSizeFactors

  2. Estimation of dispersion: estimateDispersions

  3. Negative Binomial GLM fitting and Wald statistics: nbinomWaldTest

For complete details on each step, see the manual pages of the respective functions. 

```{r DESeq calculation}
dds <- DESeq(dds)
```

## Normalized count table  

For inspection of the normalized data, we write the normalized counts into a data.frame called "norm_anno".

```{r gene annotation}
norm_anno <- as.data.frame(counts(dds, normalized=T))
norm_anno$GENEID <- row.names(norm_anno)

# add gene annotation extracted from the gtf file
gene_annotation <- tx_annotation[!duplicated(tx_annotation$GENEID),c("GENEID", "SYMBOL", "GENETYPE")]
gene_annotation <- gene_annotation[match(rownames(norm_anno), gene_annotation$GENEID),]

# check if row names of the normalized table and the gene annotation match perfectly
all(rownames(norm_anno) == gene_annotation$GENEID)

# add additional gene annotation downloaded from biomart
biomart <- read.delim(file.path(dir, "Data", "biomart_180914.txt"), stringsAsFactors = FALSE)
idx <- match(unlist(lapply(strsplit(gene_annotation$GENEID, split = "[.]"), `[[`, 1)), biomart$Gene.stable.ID)
gene_annotation$DESCRIPTION <- biomart$Gene.description[idx]
gene_annotation$CHR <- biomart$Chromosome.scaffold.name[idx]

# merge expression table and annotation
norm_anno <- merge(norm_anno,
                   gene_annotation,
                   by = "GENEID")
rownames(norm_anno) <- norm_anno$GENEID

norm_anno[1:3,c(1:2, (ncol(norm_anno)-5):ncol(norm_anno))]
```

## Variance stabilizing transformation

In order to test for differential expression, we operate on raw counts and use discrete distributions. However for other downstream analyses - e.g. for visualization or clustering - it might be useful to work with transformed versions of the count data.  

Maybe the most obvious choice of transformation is the logarithm. Since count values for a gene can be zero in some conditions (and non-zero in others), some advocate the use of pseudocounts, i.e. transformations of the form: y=log2(n+n0) where n represents the count values and n0 is a positive constant.

DESeq2 has two alternative approaches that offer more theoretical justification and a rational way of choosing parameters equivalent to n0 above. One makes use of the concept of variance stabilizing transformations (VST) (Tibshirani 1988; Huber et al. 2003; Anders and Huber 2010), and the other is the regularized logarithm or rlog, which incorporates a prior on the sample differences (Love, Huber, and Anders 2014). Both transformations produce transformed data on the log2 scale which has been normalized with respect to library size or other normalization factors.

The point of these two transformations, the VST and the rlog, is to remove the dependence of the variance on the mean, particularly the high variance of the logarithm of count data when the mean is low. Both VST and rlog use the experiment-wide trend of variance over mean, in order to transform the data to remove the experiment-wide trend. Note that we do not require or desire that all the genes have exactly the same variance after transformation. Indeed, in a figure below, you will see that after the transformations the genes with the same mean do not have exactly the same standard deviations, but that the experiment-wide trend has flattened. It is those genes with row variance above the trend which will allow us to cluster samples into interesting groups.

The two functions, vst and rlog have an argument blind, for whether the transformation should be blind to the sample information specified by the design formula. When blind equals TRUE (the default), the functions will re-estimate the dispersions using only an intercept. **This setting should be used in order to compare samples in a manner wholly unbiased by the information about experimental groups, for example to perform sample QA (quality assurance) as demonstrated below.**

However, blind dispersion estimation is not the appropriate choice if one expects that many or the majority of genes (rows) will have large differences in counts which are explainable by the experimental design, and one wishes to transform the data for downstream analysis. In this case, using blind dispersion estimation will lead to large estimates of dispersion, as it attributes differences due to experimental design as unwanted noise, and will result in overly shrinking the transformed values towards each other. By setting blind to FALSE, the dispersions already estimated will be used to perform transformations, or if not present, they will be estimated using the current design formula. Note that only the fitted dispersion estimates from mean-dispersion trend line are used in the transformation (the global dependence of dispersion on mean for the entire experiment). So setting blind to FALSE is still for the most part not using the information about which samples were in which experimental group in applying the transformation.

```{r varStab}
# Please choose to use rlog or VST for the transformation: rlog is recommended for less than 30 samples, vst for more than 30 samples for the sake of computing time

dds_vst <- rlog(dds, blind = TRUE)

# dds_vst <- vst(dds, blind = TRUE)

# For later plotting of Heatmaps, it may be useful to have a dataframe of the variance stabilized values as log2-transformed (vst_anno_log2) as well as as normal counts (vst_anno).
vst_anno_log2<-as.data.frame(assay(dds_vst))
vst_anno_log2<-merge(vst_anno_log2,norm_anno[,c("GENEID","SYMBOL","GENETYPE","DESCRIPTION","CHR")],by="row.names")
rownames(vst_anno_log2)<-vst_anno_log2$Row.names
vst_anno_log2$Row.names<-NULL

vst_anno<-as.data.frame(assay(dds_vst))
vst_anno<-2^vst_anno
vst_anno<-merge(vst_anno,norm_anno[,c("GENEID","SYMBOL","GENETYPE","DESCRIPTION","CHR")],by="row.names")
rownames(vst_anno)<-vst_anno$Row.names
vst_anno$Row.names<-NULL
```

### Plot row standard deviations versus row means

```{r meanSdPlot, echo=TRUE}
meanSdPlot(as.matrix(assay(dds_vst)), ranks = FALSE)
```

***

# 6. Exploratory Data Analysis

Specify sample annotation for plotting
```{r}
# choose columns from sampletable for heatmap annotation
plot_annotation <- sample_table[,c("Genotype","Age","pseudoaligned_reads"), drop = F]

rownames(plot_annotation) <- sample_table$ID
```


## Frequencies of gene types
```{r plot genetypes}
TypeCounts <- as.data.frame(table(norm_anno$GENETYPE))
colnames(TypeCounts) <- c("Type", "Frequency")
TypeCounts <- subset(TypeCounts, Frequency>0)

ggplot(TypeCounts, aes(x=Type, y= Frequency,  label=Frequency))+
  geom_bar(stat="identity",fill="grey",colour="grey") +
  theme_bw()+
  geom_text(size = 3, position = position_stack(vjust = 1))+
  guides(fill=FALSE)+
  theme(text = element_text(size=10),axis.text.x = element_text(angle =90, hjust = 1))+
  xlab("")
```

## Histogram of of means per gene over all samples
```{r}
rMeans <- as.data.frame(log(rowMeans(counts(dds, normalized=TRUE)),10))
colnames(rMeans) <- "rowMeans"
ggplot(rMeans, aes(x = rowMeans)) + 
  geom_histogram(bins=100) +
  xlab("log10(rowMeans)")+
  scale_x_continuous(breaks=c(0,1,2,3,4,5,6))+
  theme_bw()
```

## Boxplots of highest expressed genes

```{r, fig.height=10}
highestGenes(numGenes = 50)
```

## Hierarchical Clustering of all present genes {.tabset .tabset-fade}

Plot a heatmap of all hierarchically clustered present genes.

I case your machine has only 8 gb of ram, plotting a heatmap of all present genes might exceed your memory capacities and give the error: "Error: cannot allocate vector of size XX Gb". In that case, you can either reduce the genes to present based on a higher expression cutoff or continue with the heatmap of variable genes.

### clustered Columns & Rows
```{r, echo=TRUE, fig.height=10, fig.width=12}
plotHeatmap(input=norm_anno,geneset = "all",
            title = "Heatmap of all present genes",
            show_rownames = FALSE,
            cluster_cols = TRUE)
```

### clustered Rows
```{r, echo=TRUE, message=FALSE, results='hide', fig.height=10, fig.width=12}
plotHeatmap(input=norm_anno,geneset = "all",
                title = "Heatmap of all present genes",
                show_rownames = FALSE,
                cluster_cols = FALSE)
```

```{r,echo=FALSE,message=FALSE}
gc()
```

## Hierarchical Clustering of most variable genes {.tabset .tabset-fade}

```{r, echo=TRUE}
# define variable genes
rv = genefilter::rowVars(assay(dds_vst))
q75 = quantile(rowVars(assay(dds_vst)), .75)
q75_names = names(which(rv > q75))
```

###  clustered Columns & Rows
```{r, echo=TRUE, message=FALSE, results='hide', fig.height=10, fig.width=12}
plotHeatmap(input=norm_anno,geneset = q75_names,
                title = "Heatmap of all most variable genes",
                show_rownames = FALSE,
                cluster_cols = TRUE)
```

###  clustered Rows
```{r, echo=TRUE, message=FALSE, results='hide', fig.height=10, fig.width=12}
plotHeatmap(input=norm_anno,geneset = q75_names,
                title = "Heatmap of all most variable genes",
                show_rownames = FALSE,
                cluster_cols = FALSE)
```

## Sample-to-Sample correlation & distance {.tabset .tabset-fade}

### Correlation

```{r, fig.height=10, fig.width=12}
# Correlation based on variance-stabilized counts
sampleCor <- as.matrix(cor(assay(dds_vst), use="all.obs", method="pearson"))
rownames(sampleCor)<- sample_table$ID
colnames(sampleCor)<- sample_table$ID

pheatmap(sampleCor,
         main="Sample Correlation based on variance-stabilized counts",
         annotation_row = plot_annotation,
         annotation_col = plot_annotation,
         annotation_colors = ann_colors,
         cluster_rows = F,
         cluster_cols = F,
         fontsize = 8)
```

### Distance  
This function computes and returns the euclidean distance matrix between the rows of a data matrix, the samples in our case. 

```{r, fig.height=10, fig.width=12}
# Sample Distances based on variance-stabilized counts
sampleDist <- as.matrix(dist(t(assay(dds_vst))))
rownames(sampleDist)<- sample_table$ID
colnames(sampleDist)<- sample_table$ID

pheatmap(sampleDist,
         clustering_distance_rows = dist(t(assay(dds_vst))),
         clustering_distance_cols = dist(t(assay(dds_vst))), 
         main="Sample distances based on variance-stabilized counts per sample",
         annotation_row = plot_annotation, 
         annotation_col = plot_annotation,
         annotation_colors = ann_colors,
         fontsize = 8)
```

## Principle Component Analysis 

Related to the distance matrix is the PCA plot, which shows the samples in the 2D plane spanned by two principal components. This type of plot is useful for visualizing the overall effect of experimental covariates and batch effects.

Principal component analysis (PCA) simplifies the complexity in high-dimensional data while retaining trends and patterns. It does this by transforming the data into fewer dimensions, which act as summaries of features. High-dimensional data are very common in biology and arise when multiple features, such as expression of many genes, are measured for each sample. This type of data presents several challenges that PCA mitigates: computational expense and an increased error rate due to multiple test correction when testing each feature for association with an outcome. PCA is an unsupervised learning method and is similar to clustering1—it finds patterns without reference to prior knowledge about whether the samples come from different treatment groups or have phenotypic differences.

To understand the basics of PCA, please watch: https://www.youtube.com/watch?v=_UVHneBUBW0

### Percentage of explained variance of PCs
```{r}
# Extract the eigenvalues/variances of the principal dimensions
eigenvalue <- get_eig(prcomp(t(assay(dds_vst))))
eigenvalue$dim <- as.numeric(c(1:nrow(eigenvalue)))

ggplot(eigenvalue, aes(dim, variance.percent))+ 
  geom_bar(stat = "identity")+
  geom_line(aes(dim, variance.percent)) +
  geom_point(aes(dim, variance.percent)) +
  geom_line(aes(dim, cumulative.variance.percent), colour= "grey") + 
  geom_point(aes(dim, cumulative.variance.percent), colour= "grey") + 
  scale_x_continuous(breaks=c(1:nrow(eigenvalue)))+
  xlab("Dimensions") +
  ylab("Percentage of explained variances") +
  theme_bw()
```

### Plot PCA {.tabset .tabset-fade}
#### Genotype_Age
```{r, fig.width=6, fig.height=6, fig}
plotPCA(ntop="all", 
        xPC=1, 
        yPC=2,
        color="Genotype_Age",
        anno_colour = col_genotype_age,
        shape="Sex",
        point_size=3,
        label= "ID",
        title="Principle Component Analysis based on variance-stabilized counts")
```

#### Donor Mouse
```{r, fig.width=6, fig.height=6}
sample_table$Mouse_ID<-as.factor(sample_table$Mouse_ID)
plotPCA(ntop="all", 
        xPC=1, 
        yPC=2,
        color="Mouse_ID",
        anno_colour="NULL",
        shape="NULL",
        point_size=3,
        label= "ID",
        label_subset = "3611",
        title="Principle Component Analysis based on variance-stabilized counts")
```

#### Pseudoaligned Reads
```{r, fig.width=6, fig.height=6}
plotPCA(ntop="all", 
         xPC=1, 
         yPC=2,
         color="pseudoaligned_reads",
         anno_colour="NULL",
         shape="NULL",
         point_size=3,
         title="Principle Component Analysis based on variance-stabilized counts")
```

### PCA loadings
```{r}
plotLoadings(PC="PC1", ntop="all")
plotLoadings(PC="PC2", ntop="all")
plotLoadings(PC="PC3", ntop="all")
```

## Gene-to-Gene correlation analysis over all samples

### Positive Pearson Correlation

In the following chunk, we define the upper quartile of the variable genes and identify those genes with a high positive correlation (r>0.95).

```{r}
q75_vst = assay(dds_vst)[rowVars(assay(dds_vst)) > quantile(rowVars(assay(dds_vst)), .75),]

rcor <- rcorr(t(q75_vst),type="pearson")
rcor$sig <- rcor$P<0.05 & rcor$r>0 # define significant positive correlations
rcor_filt <- rcor$r*rcor$si
rcor_filt <- rcor_filt*upper.tri(rcor_filt)
rcor_filt<- replace(rcor_filt, which( rcor_filt==0), NA)
rcor_filt_melt <- melt(rcor_filt,na.rm = TRUE)

rcor_filt_melt_cutoff <- rcor_filt_melt[rcor_filt_melt$value>0.95,]
varR <- unique(rcor_filt_melt_cutoff$Var1)

plotHeatmap(input=norm_anno,geneset = varR,
                title = "Heatmap of all variable and co-expressed genes",
                show_rownames = FALSE,
                cluster_cols = FALSE)
```

## Expression of selected genes across conditions

Plot the expression of selected genes across conditions.

```{r}
plotSingleGene(data=norm_anno, 
                 symbol="Itgam", 
                 condition="Genotype_Age",
                 anno_colour=col_genotype_age,
                 shape= NULL)

plotSingleGene(data=norm_anno, 
                 symbol="Cst7", 
                 condition="Genotype_Age",
                 anno_colour=col_genotype_age,
                 shape= "Sex")

# Plot variance stabilized value
# plotSingleGene(data=vst_anno, 
#                  symbol="Cst7", 
#                  condition="Genotype_Age",
#                  anno_colour=col_genotype_age,
#                  shape= "Sex")
# 
# # Plot batch-corrected value
# plotSingleGene(data=removedbatch_anno, 
#                  symbol="Cst7", 
#                  condition="Genotype_Age",
#                  anno_colour=col_genotype_age,
#                  shape= "Sex")
```

## Heatmap of selected genes sets

Plot a heatmap of genes annotated to a selected GO, KEGG or Hallmark term.

```{r, fig.height= 12, fig.width=12}
plotGeneSetHeatmap(input=norm_anno,
                               cat="KEGG", 
                   term="Alzheimer disease",
                   organism = "mouse",
                   show_rownames =TRUE, 
                   cluster_cols = FALSE)
  
# plotGeneSetHeatmap(input=norm_anno,
#                                cat="HALLMARK", 
#                    term="HALLMARK_APOPTOSIS",
#                    organism = "mouse",
#                    show_rownames =TRUE, 
#                    cluster_cols = FALSE)

```

# 7. Batch effect removal

In case you observe a batch effect in the data, the following code can help to define and correct for known and unknown batch effects.

**If you did not observe a batch effect, this section should be skipped.**

## LIMMA: Known batch effects

In case the global analysis showed that your data suffers from a technical batch effect, e.g. your samples cluster according to a certain covariate such as "sex" or "date of experiment", you might want to correct for this. For known batch effects, such as sequencing day or sex, you may want to try to include the variance explained by this covariate in your later differential gene expression analysis as a co-factor. 

To check whether removing the variance caused by this covariate improves the clustering of your samples, you can correct your gene expression for this factor using limma and plot a PCA of the corrected data.

(https://bioconductor.org/packages/release/bioc/html/limma.html)

```{r}
removedbatch_dds_vst <- limmaBatchEffectRemoval(input=dds_vst,
                                                   modelfactor = "Genotype_Age",
                                                   batchfactor = "Sex",
                                                   batchfactor_2 = NULL)

# For later plotting of Heatmaps, it may be useful to have a dataframe of the batch-corrected values as log2-transformed (removedbatch_anno_log2) as well as as normal counts (removedbatch_anno).

removedbatch_anno_log2<-removedbatch_dds_vst
removedbatch_anno_log2<-merge(removedbatch_anno_log2,norm_anno[,c("GENEID","SYMBOL","GENETYPE","DESCRIPTION","CHR")],by="row.names")
rownames(removedbatch_anno_log2)<-removedbatch_anno_log2$Row.names
removedbatch_anno_log2$Row.names<-NULL


removedbatch_anno<-removedbatch_dds_vst
removedbatch_anno<-2^removedbatch_anno
removedbatch_anno<-merge(removedbatch_anno,norm_anno[,c("GENEID","SYMBOL","GENETYPE","DESCRIPTION","CHR")],by="row.names")
rownames(removedbatch_anno)<-removedbatch_anno$Row.names
removedbatch_anno$Row.names<-NULL

plotPCA(pca_input = removedbatch_dds_vst,
         ntop="all", 
         xPC=1,
         yPC=2,
         color="Genotype_Age",
         anno_colour = col_genotype_age,
         shape="Sex",
         point_size=3,
         title="PCA of batch-corrected counts")
```

You can also use the batch-corrected table as input for all heatmaps and as input for the top varying genes as displayed in the following section:

```{r}
# Heatmap of all genes
plotHeatmap(input=removedbatch_anno_log2,geneset = "all",
            title = "Heatmap of all present genes",
            show_rownames = FALSE,
            cluster_cols = TRUE)

# Hierarchical Clustering of most variable genes

# define variable genes
rv = genefilter::rowVars(removedbatch_anno_log2[,!colnames(removedbatch_anno_log2)%in%c("GENEID","SYMBOL","GENETYPE","DESCRIPTION","CHR")])
q75 = quantile(rowVars(removedbatch_anno_log2[,!colnames(removedbatch_anno_log2)%in%c("GENEID","SYMBOL","GENETYPE","DESCRIPTION","CHR")]), .75)
q75_names = names(which(rv > q75))


# clustered Columns & Rows
plotHeatmap(input=removedbatch_anno_log2,geneset = q75_names,
                title = "Heatmap of all most variable genes",
                show_rownames = FALSE,
                cluster_cols = TRUE)


# Sample-to-Sample correlation & distance 

# Correlation

# Correlation based on batch-corrected counts
sampleCor <- as.matrix(cor(removedbatch_anno_log2[,!colnames(removedbatch_anno_log2)%in%c("GENEID","SYMBOL","GENETYPE","DESCRIPTION","CHR")], use="all.obs", method="pearson"))
rownames(sampleCor)<- sample_table$ID
colnames(sampleCor)<- sample_table$ID

pheatmap(sampleCor,
         main="Sample Correlation based on variance-stabilized counts",
         annotation_row = plot_annotation,
         annotation_col = plot_annotation,
         annotation_colors = ann_colors,
         cluster_rows = F,
         cluster_cols = F,
         fontsize = 8)


# Distance  
#This function computes and returns the euclidean distance matrix between the rows of a data matrix, the samples in our case. 

# Sample Distances based on variance-stabilized counts
sampleDist <- as.matrix(dist(t(removedbatch_anno_log2[,!colnames(removedbatch_anno_log2)%in%c("GENEID","SYMBOL","GENETYPE","DESCRIPTION","CHR")])))
rownames(sampleDist)<- sample_table$ID
colnames(sampleDist)<- sample_table$ID

pheatmap(sampleDist,
         clustering_distance_rows = dist(t(assay(dds_vst))),
         clustering_distance_cols = dist(t(assay(dds_vst))), 
         main="Sample distances based on variance-stabilized counts per sample",
         annotation_row = plot_annotation, 
         annotation_col = plot_annotation,
         annotation_colors = ann_colors,
         fontsize = 8)

# Positive Pearson Correlation

#In the following chunk, we define the upper quartile of the variable genes and identify those genes with a high positive correlation (r>0.95).

q75_vst = removedbatch_anno_log2[,!colnames(removedbatch_anno_log2)%in%c("GENEID","SYMBOL","GENETYPE","DESCRIPTION","CHR")][rowVars(removedbatch_anno_log2[,!colnames(removedbatch_anno_log2)%in%c("GENEID","SYMBOL","GENETYPE","DESCRIPTION","CHR")]) > quantile(rowVars(removedbatch_anno_log2[,!colnames(removedbatch_anno_log2)%in%c("GENEID","SYMBOL","GENETYPE","DESCRIPTION","CHR")]), .75),]

rcor <- rcorr(t(q75_vst),type="pearson")
rcor$sig <- rcor$P<0.05 & rcor$r>0 # define significant positive correlations
rcor_filt <- rcor$r*rcor$si
rcor_filt <- rcor_filt*upper.tri(rcor_filt)
rcor_filt<- replace(rcor_filt, which( rcor_filt==0), NA)
rcor_filt_melt <- melt(rcor_filt,na.rm = TRUE)

rcor_filt_melt_cutoff <- rcor_filt_melt[rcor_filt_melt$value>0.95,]
varR <- unique(rcor_filt_melt_cutoff$Var1)

plotHeatmap(input=removedbatch_anno_log2,geneset = varR,
                title = "Heatmap of all variable and co-expressed genes",
                show_rownames = FALSE,
                cluster_cols = FALSE)



```

## SVA: Unknown batch effects

In case your samples do not cluster according to the condition of biological interested, but you observe distinct clustering according to an unknown latent variable, you may want to try identifying this "hidden"" batch variable using surrogate variable analysis (SVA). 

The SVA package helps to define the variance in the data set that is not explained by your variables of interest and tries to model the respective surrogate variables. These surrogate variables can be included as factors in your DESeq2 model. (http://master.bioconductor.org/packages/release/workflows/html/rnaseqGene.html#removing-hidden-batch-effects; http://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.0030161)

The goal of the sva is to remove all unwanted sources of variation while protecting the contrasts due to the primary variables. This leads to the identification of features that are consistently different between groups, removing all common sources of latent variation. In some cases, the latent variables may be important sources of biological vari-
ability. If the goal of the analysis is to identify heterogeneity in one or more subgroups, the sva function may not be appropriate.  

The first step in using the sva package is to properly format the data and create appropriate model matrices. The data should be a matrix with features (genes, transcripts, voxels) in the rows and samples in the columns. Below we obtain a matrix of normalized counts for which the average count across samples is larger than 1. This is the typical genes by samples matrix found in gene expression analyses. The sva package assumes there are two types of variables that are being considered: (1) adjustment variables and (2) variables of interest. For example, in a gene expression study the variable of interest might an indicator of cancer versus control. The adjustment variables could be the age of the patients, the sex of the patients, and a variable like the date the arrays were processed.

Two model matrices must be made: the “full model” and the “null model”. The null model is a model matrix that includes terms for all of the adjustment variables but not the variables of interest. The full model includes terms for both the adjustment variables and the variables of interest. The assumption is that you will be trying to analyze the association between the variables of interest and gene expression, adjusting for the adjustment variables. The model matrices can be created using the model.matrix() function.

After the model matrices have been created, we can apply the svaseq function to estimate batch and other artifacts. 

The svaseq function performs two different steps. First it identifies the number of latent factors that need to be estimated. If the sva function is called without the n.sv argument specified, the number of factors will be estimated for you. If you prefer a specific number of SVs, you can set the n.sv parameter accordingly.

```{r}
# Format and filter the input
dat <- counts(dds, normalized=TRUE)
idx <- rowMeans(dat) > 1
dat <- dat[idx,]

# Create the full model matrix - including both the adjustment variables and the variable of interest.  In this case we only have one variable of interest called Genotype_Age.
mod  <- model.matrix(~ Genotype_Age, colData(dds))

# The null model contains only the adjustment variables. Since we are not adjusting for any other variables in this analysis, only an intercept is included in the model.
mod0 <- model.matrix(~   1, colData(dds))
```

Apply the svaseq() function to estimate the surrogate variables:

The svaseq function returns a list with four components, sv, pprob.gam, pprob.b, n.sv:

sv is a matrix whose columns correspond to the estimated surrogate variables. They can be used in downstream analyses as described below. 
pprob.gam is the posterior probability that each gene is associated with one or more latent variables.
pprob.b is the posterior probability that each gene is associated with the variables of interest.
n.sv is the number of surrogate variables estimated by the sva.


```{r}
svseq <- svaseq(dat,
               mod,
               mod0)

svseq$sv
```

You can display whether the calculated SV correlate with any of your known covariates by changing dds$condition to the column of your sample_table that you are interested in.
```{r, fig.width=8, fig.height=6}
par(mfrow = c(2, ncol(svseq$sv)))

condition ="Sex"
for (i in 1:ncol(svseq$sv)) {
  stripchart(svseq$sv[, i] ~ dds[[condition]], vertical = TRUE, main = paste0("SV", i))
  abline(h = 0)
}

condition ="Mouse_ID"
for (i in 1:ncol(svseq$sv)) {
  stripchart(svseq$sv[, i] ~ dds[[condition]], vertical = TRUE, main = paste0("SV", i))
  abline(h = 0)
}
```


Add surrogate variables to annotation table to re-analyse the data including the surrogate variables in the analysis.

```{r}
for (i in 1:ncol(svseq$sv)) {
  sample_table[[paste0("SV",i)]]<- svseq$sv[,i]
}
```


Again, we can check in a PCA what an influence removing the SVs has on the clustering of the samples.

```{r}
removedbatch_dds_vst <- limmaBatchEffectRemoval(input=dds_vst,
                                                modelfactor = "Genotype_Age",
                                                batchfactor = c("SV1","SV2","SV3"),
                                                batchfactor_2 = NULL)

plotPCA(pca_input = removedbatch_dds_vst,
         ntop="all",
         xPC=1,
         yPC=2,
         color="Genotype_Age",
         anno_colour = col_genotype_age,
         point_size=3,
         title="PCA of batch-corrected counts")
```

## Include batch effect variables into DESeq2 model

In case you want to include the observed batch variables in your DESeq2 model, no matter if known covariates or surrogate variables, you can add these to your design formlua in front of the condition of interest and recalculate your dds object.
In the following expample we will include a Sex and three SVs as batch effects.

**ATTENTION: Skip this chunk, if you do not want to include any batch variables!**

```{r}
# ddssva <- dds
# ddssva$SV1 <- svseq$sv[,1]
# ddssva$SV2 <- svseq$sv[,2]
# ddssva$SV3 <- svseq$sv[,3]
# design(ddssva) <- ~ SV1 + SV2 + SV3 + Genotype_Age
# 
# dds <- DESeq(ddssva)
```

# 8. Differential Expression Analysis

After the DESeq() function performs the standard differential expression analysis steps, DESeq2's results() function can extract a result table from the DESeqDataSet giving base means across samples, log2 fold changes, standard errors, test statistics, p-values and adjusted p-values.

We have written a function called DEAnalysis() that runs DESeq2's results() and the lfcShrink() function with specified parameters on a set of pre-defined comparisons and returns a single DEresults object containing the respective result tables together with additional lists of the significant DE genes and the number of DE genes found.

The parameters of the DEAnalysis function are: 

  1) condition: specify the condition that you are testing, e.g. treatment or genotype. This value must correspond to the column in the colData listing the factors you are comparing and the design formula. 

  2) alpha:  a significance cutoff used for optimizing the independent filtering.(default= 0.05)
  
  3) lfcThreshold: a non-negative value which specifies a log2 fold change threshold. The default value is 0, corresponding to a test that the log2 fold changes are equal to zero. (default = 0)
  
  4) sigFC: post testing significance criteria as a non-negative, non-log transformed FC cutoff (default = 2)
  
  5) multiple_testing: By default independent hypothesis weighting will be used as the multiple testing method (https://bioconductor.org/packages/3.7/bioc/vignettes/IHW/inst/doc/introduction_to_ihw.html). However, you can also edit the multiple testing method by setting the multiple_testing parameter to "holm", "hochberg", "hommel", "bonferroni", "BH", "BY",or "fdr", which will perform independent filtering and p-value adjustment according to the specified method. (default = "IHW")
  
  6) shrinkage: After calculating differential expression statistics, we can perform a so-called log2 fold change shrinkage. This shrinkage of effect size (LFC estimates) is useful for visualization and ranking of genes, as it removes the noise associated with log2 fold changes from low count genes without requiring arbitrary filtering thresholds. To shrink the LFC, set shrinkage = TRUE to pass the dds object to the function lfcShrink.  (default = TRUE)

  7) shrinkType: The options for the shrinkage type are:

    * "normal" is the the original DESeq2 shrinkage estimator, an adaptive Normal distribution as prior.This is currently the default, although the default will likely change to apeglm in the October 2018 release given apeglm’s superior           performance.

    * "apeglm" is the adaptive t prior shrinkage estimator from the apeglm package (Zhu, Ibrahim, and Love 2018).

    * "ashr" is the adaptive shrinkage estimator from the ashr package (Stephens 2016). Here DESeq2 uses the ashr option to fit a mixture of Normal distributions to form the prior, with method="shrinkage".


## Define relevant comparisons

Define your comparisons in a data.frame with "comparison" in the first column and "control" in the second column.

comparison | control
-----------|----------
tg_4mo     | wt_4mo
tg_8mo     | wt_8mo
tg_12mo    | wt_12mo

```{r}
comparison_table<-data.frame(comparison = c("tg_4mo","tg_8mo","tg_12mo"),
                             control = c("wt_4mo","wt_8mo","wt_12mo"))
```


## Perform Differential Expression Testing

```{r}
DEresults <- DEAnalysis(condition = "Genotype_Age",
                        alpha=0.05 ,
                        lfcThreshold= 0,
                        sigFC = 2,
                        multiple_testing="IHW",
                        shrinkage = TRUE,
                        shrinkType="normal")
```

### Summary of DE genes

We use a for loop to print the number of significantly up- and down-regulated genes over all comparisons.

```{r}
DEcounts <- NULL

for(i in 1:nrow(comparison_table)){
  tmp <- unlist(DEresults[[1+i]]@Number_DE_genes)
  DEcounts <- rbind(DEcounts, tmp)
}

rownames(DEcounts) <- names(DEresults)[-1]

DEcounts
```

## 8.1 General DE Gene analysis

### Hierarchical Clustering of the union of DE genes 

```{r, echo=TRUE, message=FALSE, results='hide', fig.height=10, fig.width=12}
# the uDEG() function produces the union of the DE genes from the specified comparisons
allDEgenes <- uDEG(comparisons=c("tg_4mo_vs_wt_4mo","tg_8mo_vs_wt_8mo","tg_12mo_vs_wt_12mo"))

plotHeatmap(input=norm_anno,geneset = allDEgenes,
            title = "Heatmap of all differentially expressed genes",
            show_rownames = FALSE,
            cluster_cols = TRUE)
```

### Hierarchical Clustering of differentially expressed Transcription Factors
```{r, fig.height=16, fig.width=8}
if(organism=="mouse"){
  DE_TF <- allDEgenes[which(allDEgenes %in% norm_anno[norm_anno$SYMBOL %in% TFlist_mm,]$GENEID)]
} else if(organism =="human"){
  DE_TF <- allDEgenes[which(allDEgenes %in% norm_anno[norm_anno$SYMBOL %in% TFlist_hs,]$GENEID)]
}

plotHeatmap(input=norm_anno,geneset = DE_TF,
                title = "Heatmap of all differentially expressed transcription factors",
                show_rownames = TRUE,
                cluster_cols = FALSE)
```

### Venn diagrams

```{r, fig.height=10, fig.width=10}
plotVenn(comparisons =  c("tg_4mo_vs_wt_4mo", "tg_8mo_vs_wt_8mo"),
         regulation ="up")

plotVenn(comparisons =  c("tg_12mo_vs_wt_12mo", "tg_8mo_vs_wt_8mo"))
```


### Ratio-Ratio plots of DE genes

Ratio-Ratio plots help to compare the DE genes of two comparisons and are much more expressive than venn diagrams. 

```{r}
plotRatios(comp1 = "tg_4mo_vs_wt_4mo", 
           comp2 = "tg_8mo_vs_wt_8mo")
plotRatios(comp1 = "tg_8mo_vs_wt_8mo",
           comp2 = "tg_12mo_vs_wt_12mo")
plotRatios(comp1 = "tg_4mo_vs_wt_4mo",
           comp2 = "tg_12mo_vs_wt_12mo")
```


### Fold change rank plots
```{r, fig.height=6,fig.width=6}
plotFCrank(comp1 = "tg_4mo_vs_wt_4mo", 
           comp2 = "tg_8mo_vs_wt_8mo")

```

### GSEA across comparisons

Define universe and gene sets for subsequent GSEA analyses.

```{r}
# define universe
universe <- as.character(norm_anno$SYMBOL)
# change symbols to ENTREZ IDs (necessary for ClusterProfiler)
universe_Entrez <- bitr(universe, 
                        fromType="SYMBOL", 
                        toType="ENTREZID", 
                        OrgDb="org.Mm.eg.db")$ENTREZID

universe_mouse2human <- getLDS(attributes = c("mgi_symbol"), 
                              filters = "mgi_symbol", 
                              values = universe, 
                              mart = useMart("ensembl", dataset = "mmusculus_gene_ensembl"), 
                              attributesL = c("hgnc_symbol"), 
                              martL = useMart("ensembl", dataset = "hsapiens_gene_ensembl"), 
                              uniqueRows=T)[,2]

universe_mouse2human_Entrez <- bitr(universe_mouse2human, 
                        fromType="SYMBOL", 
                        toType="ENTREZID", 
                        OrgDb="org.Hs.eg.db")$ENTREZID
```

Next, we perform functional enrichment analysis based on Gene ontology and KEGG pathway enrichment across all comparisons tested to check for overlap in functional indications of the differentially regulated genes. 

```{r, fig.height=8, fig.width=12, warnings=FALSE, message=FALSE}
DEcompare <- compareGSEA(comparisons = c("tg_4mo_vs_wt_4mo","tg_8mo_vs_wt_8mo","tg_12mo_vs_wt_12mo"),
                         organism = "mouse",
                         GeneSets = c("GO", "KEGG"),
                         pCorrection = "bonferroni", 
                         pvalueCutoff = 0.05,
                         qvalueCutoff = 0.05,
                         showMax = 20, 
                         ontology = "BP")

DEcompare$GOplot
DEcompare$KEGGplot
```

### Likelihood ratio test

DESeq2 offers two kinds of hypothesis tests: the Wald test, where we use the estimated standard error of a log2 fold change to test if it is equal to zero, and the likelihood ratio test (LRT). The LRT examines two models for the counts, a full model with a certain number of terms and a reduced model, in which some of the terms of the full model are removed. The test determines if the increased likelihood of the data using the extra terms in the full model is more than expected if those extra terms are truly zero.

**The LRT is therefore useful for testing multiple terms at once, for example testing 3 or more levels of a factor at once, or all interactions between two variables.** The LRT for count data is conceptually similar to an analysis of variance (ANOVA) calculation in linear regression, except that in the case of the Negative Binomial GLM, we use an analysis of deviance (ANODEV), where the deviance captures the difference in likelihood between a full and a reduced model.

The likelihood ratio test can be performed by specifying test="LRT" when using the DESeq function, and providing a reduced design formula, e.g. one in which a number of terms from design(dds) are removed. The degrees of freedom for the test is obtained from the difference between the number of parameters in the two models. A simple likelihood ratio test, if the full design was ~Genotype_Age would look like:

```{r}
dds_lrt <- DESeq(dds, 
                 test="LRT", 
                 reduced=~1)

res_lrt <- results(dds_lrt)

# Plot heatmap of significantly different genes 
lrt_significantGenes <- rownames(res_lrt[!is.na(res_lrt$padj)&
                                           res_lrt$padj < 0.05 ,])
plotHeatmap(input=norm_anno,geneset = lrt_significantGenes,
                title = paste("Heatmap of all LRT-significant genes: ",length(lrt_significantGenes), sep=""),
                show_rownames = FALSE,
                cluster_cols = TRUE)

# Plot heatmap of 1000 top significant genes
lrt_1000mostvariableGenes <- head(rownames(res_lrt[order(res_lrt$padj),]),1000)

plotHeatmap(input=norm_anno,geneset = lrt_1000mostvariableGenes,
                title = "Heatmap of 1000 top significant LRT genes",
                show_rownames = FALSE,
                cluster_cols = TRUE)
```


## 8.2 Specific DE Gene analysis

Now that we have had a global look at the differentially expressed genes, we want to have a more detailed look at specific comparisons. Therefore, we use various plots to get an impression of the differences in the specified comparisons.

### MAplots

A MAplot represents the average log expression versus the average ratio (or fold change) between two conditions.

```{r}
  plotMA(comparison = "tg_4mo_vs_wt_4mo",
         ylim=c(-2,2))
  plotMA(comparison = "tg_8mo_vs_wt_8mo",
         ylim=c(-2,2))
  plotMA(comparison = "tg_12mo_vs_wt_12mo",
         ylim=c(-2,2))
```

### p value distributions

We plot a histogram of the p-values resulting from testing the specified comparisons.

To understand p-value distributions, this source is very helpful:
http://varianceexplained.org/statistics/interpreting-pvalue-histogram/

```{r}
  plotPvalues(comparison="tg_4mo_vs_wt_4mo")
  plotPvalues(comparison="tg_8mo_vs_wt_8mo")
  plotPvalues(comparison="tg_12mo_vs_wt_12mo")
```

### Heatmaps of DE genes

Plot heatmaps of the expression of the DE genes of the specified comparisons. The argument conditions allows to include samples from specified conditions in the heatmap.

```{r}
  plotDEHeatmap(input=norm_anno,
                               "tg_4mo_vs_wt_4mo",
                factor="Genotype_Age",
                conditions="all")
  
  plotDEHeatmap(input=norm_anno,
                               "tg_4mo_vs_wt_4mo",
                factor="Genotype_Age",
                conditions=c("tg_4mo","wt_4mo","wt_12mo"))
  
  plotDEHeatmap(input=norm_anno,
                               "tg_4mo_vs_wt_4mo",
                factor="Genotype_Age",
                conditions=c("tg_4mo","wt_4mo"))
  
  plotDEHeatmap(input=norm_anno,
                               "tg_8mo_vs_wt_8mo",
                factor="Genotype_Age",
                conditions=c("tg_8mo","wt_8mo"))
  
  plotDEHeatmap(input=norm_anno,
                               "tg_12mo_vs_wt_12mo",
                factor="Genotype_Age",
                conditions=c("tg_12mo","wt_12mo"))
```

### Volcano Plots

A volcano plot is a type of scatter-plot that is used to quickly identify changes in large data sets composed of replicate data. It plots significance versus fold-change on the y and x axes, respectively. 

```{r}
# Plot Volcano Plot
  plotVolcano(comparison= "tg_4mo_vs_wt_4mo",
              labelnum=20)
  plotVolcano(comparison= "tg_8mo_vs_wt_8mo",
              labelnum=20)
  plotVolcano(comparison= "tg_12mo_vs_wt_12mo",
              labelnum=20)
```

### Gene Set Enrichment of DE genes

Next, we perform gene set enrichment analyses of the DE genes of the specified comparisons. 

6 gene sets are available:
  * GO
  * KEGG
  * MSigDB Hallmark (H)
  * MSigDB Cannonical Pathways (C2) *Gene sets from pathway databases. Usually, these gene sets are canonical representations of a biological process compiled by domain experts.*  
  * MSigDB Motifs (C3, DNA binding motifs) *Gene sets representing potential targets of regulation by transcription factors or microRNAs. The sets consist of genes grouped by short sequence motifs they share in their non-protein coding regions. The motifs represent known or likely cis-regulatory elements in promoters and 3'-UTRs. The C3 collection is divided into two sub-collections: MIR and TFT*  
  * MSigDB Immunologic gene sets (C7) *Gene sets that represent cell states and perturbations within the immune system. The signatures were generated by manual curation of published studies in human and mouse immunology.*

```{r, fig.height=6, fig.width=8}
GSEA_tg_4mo_vs_wt_4mo <-  GSEA(comparison="tg_4mo_vs_wt_4mo",
                                 organism="mouse",
                                 GeneSets = c("GO",
                                              "KEGG",
                                              "Hallmark",
                                              "cannonicalPathways",
                                              "Motifs",
                                              "ImmunoSignatures"),
                                 GOntology = "BP",
                                 pCorrection = "bonferroni", # choose the p-value adjustment method
                                 pvalueCutoff = 0.2, # set the unadj. or adj. p-value cutoff (depending on correction method)
                                 qvalueCutoff = 0.2 # set the q-value cutoff (FDR corrected)
                                 )

dotplotGSEA(GSEA_tg_4mo_vs_wt_4mo$GOup,
            font.size = 12,
            title.size=12,
            title.width = 40)

dotplotGSEA(GSEA_tg_4mo_vs_wt_4mo$KEGGup)
```

#### Heatmaps of GSEA result responsible genes

Please make sure that the specified terms are enriched terms of the selected results.

```{r}
plotGSEAHeatmap(input=norm_anno,
                               GSEA_result = GSEA_tg_4mo_vs_wt_4mo$GOup, 
              GeneSet="GO", 
              term = "synapse organization")
```

# 9. Export

## Count table as txt file
Exporting the annotated, normalized expression table:
```{r}
write.table(norm_anno,
            paste(dir, "/Analysis/", "Tables/", "DESeq2_norm_anno_", Sys.Date(), ".txt", sep = ""),
            sep = "\t",
            quote = F,
            row.names = F)
```

## Export as Excel sheet

As an optimal output for cooperation partners, we create an Excel workbook with the normalized count table, the rlog-transformed counts, the DE test parameters & the statistics of the respective differential expression tests. 

```{r , echo=TRUE, message=FALSE}
# create Workbook
ExcelOutput<-createWorkbook()

# add sample table
sheet <- addWorksheet(ExcelOutput, sheetName = "Samples")
writeDataTable(ExcelOutput, sheet, sample_table, withFilter=FALSE)

# add normalized counts
tmp <- norm_anno
tmp$LRT_padj <- res_lrt$padj
sheet <- addWorksheet(ExcelOutput, sheetName = "Normalized counts & Annotation")
writeDataTable(ExcelOutput, sheet, tmp, withFilter=FALSE)

# add variance-stabilized counts
tmp <- as.data.frame(assay(dds_vst))
tmp$GENEID <- norm_anno$GENEID
tmp$SYMBOL <- norm_anno$SYMBOL
sheet <- addWorksheet(ExcelOutput, sheetName = "Variance-stabilized counts")
writeDataTable(ExcelOutput, sheet, tmp, withFilter=FALSE)

# add batch-corrected counts
tmp <- as.data.frame(removedbatch_anno)
sheet <- addWorksheet(ExcelOutput, sheetName = "Batch-corrected counts")
writeDataTable(ExcelOutput, sheet, tmp, withFilter=FALSE)

# add DE test parameters
tmp <- stack(unlist(DEresults$parameters))
colnames(tmp)<-c("value","parameter")
tmp <- rbind(tmp, data.frame(value = as.character(design(dds))[2], parameter = "design"))
sheet <- addWorksheet(ExcelOutput, sheetName = "DE parameters")
writeDataTable(ExcelOutput, sheet, tmp, withFilter=FALSE)

# add combined DE results
cResults <- NULL
for (i in 2:length(names(DEresults))) {
  if(i == 2){
    cResults<-data.frame(DEresults[[i]]@results[,c("GENEID","SYMBOL","baseMean","log2FoldChange","padj","regulation")])
    colnames(cResults)[4:6]<- paste(names(DEresults)[i],colnames(cResults)[4:6],sep="_")
  }else{
    tmp<-data.frame(DEresults[[i]]@results[,c("log2FoldChange","padj","regulation")])
    colnames(tmp)<- paste(names(DEresults)[i],colnames(tmp),sep="_")    
    cResults<-cbind(cResults,tmp)
  }
}
sheet <- addWorksheet(ExcelOutput, sheetName = "combined DE Results")
writeDataTable(ExcelOutput, sheet, cResults, withFilter=FALSE)

# add DE results in single sheets
for(i in 2:length(names(DEresults))){
  gc()
  sheet <- addWorksheet(ExcelOutput, sheetName = substr(names(DEresults[i]),1 , 30))
  writeDataTable(ExcelOutput, sheet, DEresults[[i]]@results, withFilter=FALSE)
  sheet <- addWorksheet(ExcelOutput, sheetName = paste(substr(names(DEresults[i]),1 , 22),"_upDEGs"))
  writeDataTable(ExcelOutput, sheet, DEresults[[i]]@DE_genes$up_regulated_Genes, withFilter=FALSE)
  sheet <- addWorksheet(ExcelOutput, sheetName = paste(substr(names(DEresults[i]),1 , 20),"_downDEGs"))
  writeDataTable(ExcelOutput, sheet, DEresults[[i]]@DE_genes$down_regulated_Genes, withFilter=FALSE)
  }

# Save Workbook
filename <- paste(dir,"/Analysis/Tables/AnalysisOutput_",gsub(":","-",as.character(Sys.time())),".xlsx",sep="")
saveWorkbook(ExcelOutput, file=filename)
```

# 10. Save image and session Info
```{r}
save.image(paste(dir, "/Analysis/", Sys.Date(), "_Image.RData", sep = ""))
sessionInfo()
```